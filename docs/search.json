[
  {
    "objectID": "index_es.html",
    "href": "index_es.html",
    "title": "Posts",
    "section": "",
    "text": "Blockchain, ¿qué es eso?\n\n\n\n\n\n\n\nBlockchain\n\n\nCriptografia\n\n\n\n\n\n\n\n\n\n\n\n28 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nCrea tu propia blockchain\n\n\n\n\n\n\n\nPython\n\n\nBlockchain\n\n\nCriptografia\n\n\n\n\n\n\n\n\n\n\n\n20 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "posts/es/blockchain_0/index.html",
    "href": "posts/es/blockchain_0/index.html",
    "title": "Blockchain, ¿qué es eso?",
    "section": "",
    "text": "En este post intento explicar lo que es una blockchain de la forma más simple, visual e interactiva posible. No es necesario tener conocimientos de programación o criptografía para entender como funciona una blockchain. Si quieres entrar más en detalle tengo otro post explicando como programar una blockchain en Python desde cero."
  },
  {
    "objectID": "posts/es/blockchain_0/index.html#función-hash",
    "href": "posts/es/blockchain_0/index.html#función-hash",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Función hash",
    "text": "Función hash\nLa función hash es una de las herramientas criptográficas más importantes y es imprescindible para crear una blockchain. Aunque el funcionamiento interno de una función hash puede ser muy complicado, el concepto es bastante simple. Se trata de una función que convierte una entrada (la palabra “hola” por ejemplo) en un a salida que a priori parece aleatoria, aunque no lo es.\n\n\n\n\n\nLo que hace a la función hash tan útil es que siempre devuelve un resultado del mismo tamaño. Existen muchos tipos de algoritmos hash diferentes, uno de los mas usados es el SHA256, que devuelve 256 bits. Da igual que la entrada de la función sea la letra “a” o el Quijote entero, siempre el resultado son 256 bits. A continuación, puedes probar a experimentar con la función hash:\n#| standalone: true\nimport hashlib as hs\nfrom shiny import *\n\napp_ui = ui.page_fluid(\n  ui.tags.style(\n        \"\"\"\n        .app-col {\n            border: 1px solid white;\n            border-radius: 5px;\n            background-color: #ffffff;\n            padding: 8px;\n            margin-top: 5px;\n            margin-bottom: 2px;\n        }\n        \"\"\"\n    ),\n  \n  ui.row(\n    ui.div(\n                {\"class\": \"app-col\"},\n                ui.p(\n                    ui.input_text(\"x\", \"\", placeholder=\"hola\",width=\"75%\"), \n                ),\n                ui.p(\n                    ui.output_text(\"txt\"),\n                ),\n            ),\n            align=\"center\",\n)\n)\n\ndef server(input, output, session):\n  @output\n  @render.text\n  def txt():\n    if len(input.x()) == 0:\n      hash = hs.sha256((\"hola\").encode()).hexdigest()\n    else:\n      hash = hs.sha256((input.x()).encode()).hexdigest()\n    return f'{hash}'\n\n\napp = App(app_ui, server, debug=True)\n\nLa función hash es caótica, es decir que un minúsculo cambio en la entrada (por ejemplo, poner la “h” en mayúscula) provoca un resultado completamente diferente. Es importante distinguir caótico de aleatorio, la función hash no es aleatoria, es determinista, siempre devolverá la misma salida a la misma entrada. Se podría comparar la función hash con el sistema de doble péndulo, otro ejemplo de sistema caótico. En un doble péndulo las entradas serian los ángulos iniciales de los péndulos, y la salida el movimiento resultante. Cambiar un poquito las condiciones iniciales del doble péndulo provoca resultados de movimiento completamente diferentes. En el ejemplo inferior parece que los dos péndulos empiezan igual al principio, pero en realidad tienen un cambio despreciable en el ángulo inicial, pero este minúsculo cambio es suficiente para alterar por completo el resultado.\n\n\n\n\n\n\n\n\n\n\nOtra característica del sistema de doble péndulo es que pasado un tiempo es prácticamente imposible deducir el estado inicial del péndulo. De la misma forma, es imposible conocer que entrada a la función hash dará un resultado especifico o, en otras palabras, es imposible hacer la función hash al revés. La única forma de saber que resultado dará una entrada es realizando la función hash sobre esa entrada.\nSi recuerdas los problemas mencionados antes, la función hash resuelve uno de los problemas: codificar la información de cada página (o bloque) de una forma única, determinista y con un tamaño fijo. De esta forma los bloques se “encadenan” porque cada bloque contiene el hash del bloque anterior. Como el hash del bloque anterior se incluye para obtener el hash del bloque posterior, modificar un solo número provoca cambios radicales en todos los hashes de los bloques posteriores, es decir: están encadenados.\n\n\n\n\n\nLa función hash también permite implementar la prueba de trabajo. Computar la función hash requiere una cantidad de tiempo. Como podías ver en la función hash interactiva de antes, no se tarda mucho en calcular, pero si se ejecuta millones de veces la cantidad de tiempo es significativa. Para implementar la prueba de trabajo en una blockchain podemos, añadir una variable libre (nonce) a la entrada de la función hash y exigir que el hash de cada bloque empiece por \"0000\". Como es imposible saber que entrada resultara en un hash que comience por \"0000\", la única forma es probar y probar hasta acertar. Este proceso de probar miles de entradas posibles para la función hash requiere computación y tiempo. Por ejemplo, usando la palabra \"hola\" como entrada del hash, probamos \"hola_0\", \"hola_1\", \"hola_2\"… Al final después de un tiempo resolvemos la prueba de trabajo, si probamos con \"hola_167537\"obtenemos el hash que comienza con 4 ceros:\n\n0000c24a5157df9c08de36972e30404e463b1e76bbb25007395d455b9494ad77"
  },
  {
    "objectID": "posts/es/blockchain_0/index.html#firma-digital",
    "href": "posts/es/blockchain_0/index.html#firma-digital",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Firma digital",
    "text": "Firma digital\nLa firma digital, como una firma real, nos permite marcar información de tal manera que cualquiera pueda comprobar que efectivamente, esa información firmada la hemos creado nosotros. Sin esta herramienta una criptomoneda no podría funcionar ya que cualquier miembro de la blockchain podría hacerse pasar por otra persona. Si nos paramos a pensar, qué es una firma, no es más que modificar un documento con una marca que solo la persona que firma puede hacer. El proceso de firmar un documento es bastante intuitivo, pero ¿cómo puede alguien comprobar que la firma es de verdad? Aquí es donde entra en juego la encriptación asimétrica. La encriptación no es más que el proceso de bloquear o esconder algo del acceso público. Las puertas normales de nuestras casas son un tipo de “encriptación” simétrica. Tenemos una llave que es la misma que cierra o abre la puerta, es decir, el proceso de abrir es simétrico al de cerrar. Lo mismo pasa con los candados de la bici o las taquillas. En cambio, en una encriptación asimétrica hay dos llaves: una que cierra y otra que abre. Si nuestras casas tuvieran puertas asimétricas necesitaríamos una llave diferente para abrir la puerta que para cerrarla. Parece complicarse para nada, pero esto es extremadamente útil para las firmas digitales.\n\n\nEncriptación asimetrica:\n\n\n\nEn una firma digital la llave de cerrar es la llave privada, y la de abrir la pública. La llave pública se genera a partir de la llave privada, pero es imposible conocer la llave privada sabiendo únicamente la pública. Digamos que Alicia tiene un par de llaves publica y privada y quiere firmar una carta. La pública la puede ver cualquiera, y la privada solo la conoce ella. Alicia encripta una carta usando su llave privada y se la manda a Juan. Recordemos que esa carta ahora únicamente se puede abrir con la llave pública de Alicia. Juan abre la carta con la llave publica de Alicia y de esta forma Juan sabe que esa carta la ha encriptado Alicia con su llave privada, sin tener que conocer cual es la llave privada de Alicia."
  },
  {
    "objectID": "posts/es/blockchain_1/index.html",
    "href": "posts/es/blockchain_1/index.html",
    "title": "Crea tu propia blockchain",
    "section": "",
    "text": "En este post explico como programar una blockchain, especificamente una criptomoneda, desde cero en Python. Te recomiendo que le eches un vistazo a mi otro post que explica el funcionamiento de una blockchain."
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#transacciones",
    "href": "posts/es/blockchain_1/index.html#transacciones",
    "title": "Crea tu propia blockchain",
    "section": "Transacciones",
    "text": "Transacciones\n\n\n\n\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n\n\n\n\n\n\n\n\nEmpezaremos creando la clase Transaction. Los objetos de este tipo recogen las propiedades de las transacciones, estas son el emisor, receptor y valor de la transacción:\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#bloque",
    "href": "posts/es/blockchain_1/index.html#bloque",
    "title": "Crea tu propia blockchain",
    "section": "Bloque",
    "text": "Bloque\n\n\n\n\nclassDiagram\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n\n\n\n\n\n\n\n\nDefinimos una clase Block que representa cada bloque de la blockchain. Los bloques tiene como atributos: el conjunto de transacciones (transactions), el sello temporal (timestamp) que indica cuando se creo el bloque, el hash del bloque anterior (prevHash), el hash del bloque (hash) y la variable libre (nonce). La función calculateHash() calcula el hash del bloque usando el algoritmo SHA256 y tomando como entrada los atributos del bloque. La función mineBlock(difficulty) ejecuta la prueba de trabajo en un bucle que incrementa la variable nonce hasta que encuentra el hash correspondiente que comienza con el numero de ceros especificado por la dificultad de minado.\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#blockchain",
    "href": "posts/es/blockchain_1/index.html#blockchain",
    "title": "Crea tu propia blockchain",
    "section": "Blockchain",
    "text": "Blockchain\n\n\n\n\nclassDiagram\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n\n\n\n\n\n\n\n\nLa clase Blockchain tiene como atributos la difficultad de mindao, la recompensa de minado, la lista chain que contiene los bloques y la lista de transacciones pendientes para añadir al siguiente bloque. Al inicializar un objeto Blockchain se crea el bloque genesis (createGenBlock()). La función addBlock(newBlock) añade un nuevo bloque a la cadena obteniendo el hash del ultimo bloque y minando el nuevo bloque. La función minePending(minnerAddress) coge las transacciones pendientes y añade la transacción de recompensa de minado. Posteriormente crea un nuevo bloque, ejecuta la función addBlock(newBlock) con el nuevo bloque creado y vacia la lista de transacciones pendientes.\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #La direccion desde donde se manda la recompensa de minar\n    \n    def __init__(self):\n        self.difficulty = 2         #El numero de ceros por el que empieza el hash del nuevo bloque\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#prueba",
    "href": "posts/es/blockchain_1/index.html#prueba",
    "title": "Crea tu propia blockchain",
    "section": "Prueba",
    "text": "Prueba\n\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n\nBlock mined: 00d407dd89771414f4e1e82345e3b52a1caa06e0a530329f18678ef512339265\nBlock mined: 007e3bfeac81d55dbe56d173b6eb4b6a3d0da5ccf02d4eea71806f480ffb2248\n\nBalance Alice: 75\nBalance Bob: 125\n\n\n\nzcoin.isValid()\n\nTrue"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#firma-digital",
    "href": "posts/es/blockchain_1/index.html#firma-digital",
    "title": "Crea tu propia blockchain",
    "section": "Firma digital",
    "text": "Firma digital\npip install eciespy\n\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n\nPrivate:  fb0df14ef1ff94723dcd30bdb2d730a2f3aea9adaf649dc980fcb185bd72f4b4\nPublic:  03dccf383a774a2d7e731f074d19c0c1728192e21b86084c785da1af25f9455757\n\n\n\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\nTrue\n03dccf383a774a2d7e731f074d19c0c1728192e21b86084c785da1af25f9455757"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#transacciones-1",
    "href": "posts/es/blockchain_1/index.html#transacciones-1",
    "title": "Crea tu propia blockchain",
    "section": "Transacciones",
    "text": "Transacciones\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#bloque-1",
    "href": "posts/es/blockchain_1/index.html#bloque-1",
    "title": "Crea tu propia blockchain",
    "section": "Bloque",
    "text": "Bloque\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ])"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#blockchain-1",
    "href": "posts/es/blockchain_1/index.html#blockchain-1",
    "title": "Crea tu propia blockchain",
    "section": "Blockchain",
    "text": "Blockchain\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True"
  },
  {
    "objectID": "posts/es/blockchain_1/index.html#prueba-1",
    "href": "posts/es/blockchain_1/index.html#prueba-1",
    "title": "Crea tu propia blockchain",
    "section": "Prueba",
    "text": "Prueba\n\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n\nMy address: 03a0ba1629f1e5c4bf90f6ac800cfc44626ac557968dddf37601e0da618af6a1f2\nAlice address: 03dd48d41ab4bf759b1a34a52d10fe7ececd5570da95e7072395f1e228df975347\nBob address: 03c7aac89ed2668f35627ca16dabf3db3fa862be348a9a3563525b85fbd5952fed\n\n\n\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 009c79fed0a87124691dc6aa983766e4b251e5f3e3386c83402df35ee8ef4d9f\nMy balance: 100\n\n\n\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00ed62959aca0eb48d1631c60ff15c364b4a807433152c8c6f3cb01770a22304\nMy balance: 25"
  },
  {
    "objectID": "posts/en/blockchain_0/index.html",
    "href": "posts/en/blockchain_0/index.html",
    "title": "Blockchain, what is it?",
    "section": "",
    "text": "In this post I try to explain what a blockchain is in the simplest, most visual and interactive way possible. It is not necessary to have knowledge of programming or cryptography to understand how a blockchain works. If you want to go into more detail, I have another post explaining how to program a blockchain in Python from scratch."
  },
  {
    "objectID": "posts/en/blockchain_0/index.html#hash-function",
    "href": "posts/en/blockchain_0/index.html#hash-function",
    "title": "Blockchain, what is it?",
    "section": "hash function",
    "text": "hash function\nThe hash function is one of the most important cryptographic tools and is essential to create a blockchain. Although the inner workings of a hash function can be very complicated, the concept is quite simple. It is a function that converts an input (the word “hello” for example) into an output that a priori seems random, although it is not.\n\n\n\n\n\nWhat makes the hash function so useful is that it always returns a result of the same size. There are many different types of hash algorithms, one of the most used is SHA256, which returns 256 bits. It doesn’t matter if the input of the function is the letter “a” or the whole Quixote, the result is always 256 bits. You can then try experimenting with the hash function:\n#| standalone: true\nimport hashlib as hs\nfrom shiny import *\n\napp_ui = ui.page_fluid(\n  ui.tags.style(\n        \"\"\"\n        .app-col {\n            border: 1px solid white;\n            border-radius: 5px;\n            background-color: #ffffff;\n            padding: 8px;\n            margin-top: 5px;\n            margin-bottom: 2px;\n        }\n        \"\"\"\n    ),\n  \n  ui.row(\n    ui.div(\n                {\"class\": \"app-col\"},\n                ui.p(\n                    ui.input_text(\"x\", \"\", placeholder=\"hola\",width=\"75%\"), \n                ),\n                ui.p(\n                    ui.output_text(\"txt\"),\n                ),\n            ),\n            align=\"center\",\n)\n)\n\ndef server(input, output, session):\n  @output\n  @render.text\n  def txt():\n    if len(input.x()) == 0:\n      hash = hs.sha256((\"hola\").encode()).hexdigest()\n    else:\n      hash = hs.sha256((input.x()).encode()).hexdigest()\n    return f'{hash}'\n\n\napp = App(app_ui, server, debug=True)\n\nThe hash function is chaotic, meaning that a tiny change in the input (for example, capitalizing “h”) causes a completely different result. It is important to distinguish chaotic from random, the hash function is not random, it is deterministic, it will always return the same output to the same input. One could compare the hash function with the double pendulum system, another example of a chaotic system. In a double pendulum, the inputs would be the initial angles of the pendulums, and the output would be the resulting movement. Changing the initial conditions of the double pendulum a bit causes completely different motion results. In the example below it appears that the two pendulums start out the same at first, but actually have a negligible change in initial angle, but this tiny change is enough to completely alter the result.\n\n\n\n\n\n\n\n\n\n\nAnother characteristic of the double pendulum system is that after a while it is practically impossible to deduce the initial state of the pendulum. In the same way, it is impossible to know which input to the hash function will give a specific result or, in other words, it is impossible to hash the function backwards. The only way to know what result an input will give is by performing the hash function on that input.\nIf you remember the problems mentioned before, the hash function solves one of the problems: encoding the information of each page (or block) in a unique, deterministic way and with a fixed size. In this way the blocks are “chained” because each block contains the hash of the previous block. Since the hash of the previous block is included to obtain the hash of the subsequent block, changing a single number causes radical changes to all the hashes of subsequent blocks, ie: they are chained.\n\n\n\n\n\nThe hash function also allows you to implement proof of work. Computing the hash function requires a certain amount of time. As you could see from the interactive hash function above, it doesn’t take very long to compute, but if it runs millions of times the amount of time is significant. To implement proof of work in a blockchain, we can add a free variable (nonce) to the input of the hash function and require that the hash of each block start with \"0000\". Since it is impossible to know which input will result in a hash beginning with \"0000\", the only way is to try and test until you succeed. This process of testing thousands of possible inputs for the hash function requires computation and time. For example, using the word \"hello\" as input to the hash, we test \"hello_0\", \"hello_1\", \"hello_2\"… In the end after some time we solve the proof of work, if we try with \"hello_167537\" we get the hash that starts with 4 zeros:\n\n0000c24a5157df9c08de36972e30404e463b1e76bbb25007395d455b9494ad77"
  },
  {
    "objectID": "posts/en/blockchain_0/index.html#digital-signature",
    "href": "posts/en/blockchain_0/index.html#digital-signature",
    "title": "Blockchain, what is it?",
    "section": "Digital signature",
    "text": "Digital signature\nThe digital signature, like a real signature, allows us to mark information in such a way that anyone can verify that indeed, that signed information has been created by us. Without this tool, a cryptocurrency could not function since any member of the blockchain could impersonate another person. If we stop to think, what is a signature, it is nothing more than modifying a document with a brand that only the person who signs can do. The process of signing a document is quite intuitive, but how can someone verify that the signature is real? This is where asymmetric encryption comes into play. Encryption is nothing more than the process of blocking or hiding something from public access. The normal doors of our houses are a type of symmetrical “encryption”. We have a key that is the same one that closes or opens the door, that is, the opening process is symmetrical to that of closing. The same goes for bike locks or lockers. On the other hand, in an asymmetric encryption there are two keys: one that closes and another that opens. If our houses had asymmetrical doors, we would need a different key to open the door than to close it. It doesn’t seem complicated at all, but this is extremely useful for digital signatures.\n\n\nAsymmetric encryption:\n\n\n\nIn a digital signature, the closing key is the private key, and the opening key is the public one. The public key is generated from the private key, but it is impossible to know the private key knowing only the public one. Let’s say Alice has a public and private key pair and wants to sign a letter. The public one can be seen by anyone, and the private one is only known to her. Alicia encrypts a letter using her private key and sends it to Juan. Remember that this letter can now only be opened with Alicia’s public key. Juan opens the letter with Alicia’s public key and in this way Juan knows that this letter has been encrypted by Alicia with her private key, without having to know what Alicia’s private key is."
  },
  {
    "objectID": "posts/en/blockchain_1/index.html",
    "href": "posts/en/blockchain_1/index.html",
    "title": "Make your own blockchain",
    "section": "",
    "text": "In this post I explain how to program a blockchain, specifically a cryptocurrency, from scratch in Python. I recommend that you take a look at my other post that explains how a blockchain works."
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#transactions",
    "href": "posts/en/blockchain_1/index.html#transactions",
    "title": "Make your own blockchain",
    "section": "Transactions",
    "text": "Transactions\n\n\n\n\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n\n\n\n\n\n\n\n\nWe’ll start by creating the Transaction class. Objects of this type collect the properties of the transactions, these are the sender, receiver and value of the transaction:\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#block",
    "href": "posts/en/blockchain_1/index.html#block",
    "title": "Make your own blockchain",
    "section": "Block",
    "text": "Block\n\n\n\n\nclassDiagram\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n\n\n\n\n\n\n\n\nWe define a Block class that represents each block on the blockchain. The blocks have as attributes: the set of transactions (transactions), the time stamp (timestamp) that indicates when the block was created, the hash of the previous block (prevHash), the hash of the block (hash) and the free variable (nonce). The calculateHash() function calculates the hash of the block using the SHA256 algorithm and taking the block’s attributes as input. The mineBlock(difficulty) function executes the proof of work in a loop that increments the nonce variable until it finds the corresponding hash that starts with the number of zeroes specified by the mining difficulty.\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#blockchain",
    "href": "posts/en/blockchain_1/index.html#blockchain",
    "title": "Make your own blockchain",
    "section": "Blockchain",
    "text": "Blockchain\n\n\n\n\nclassDiagram\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n\n\n\n\n\n\n\n\nThe Blockchain class has as attributes the difficulty of mining, the mining reward, the chain list that contains the blocks and the list of pending transactions to add to the next block. Initializing a Blockchain object creates the genesis block (createGenBlock()). The addBlock(newBlock) function adds a new block to the chain by getting the hash of the last block and mining the new block. The minePending(minnerAddress) function takes the pending transactions and adds the mining reward transaction. It then creates a new block, executes the addBlock(newBlock) function with the newly created block, and clears the list of pending transactions.\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #The address from which the mining reward is sent\n    \n    def __init__(self):\n        self.difficulty = 2         #The number of zeros with which the hash of the new block begins\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#test",
    "href": "posts/en/blockchain_1/index.html#test",
    "title": "Make your own blockchain",
    "section": "Test",
    "text": "Test\n\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n\nBlock mined: 0042e2568d4893d988de77aec36f435e9724f4b68d8fc2c8097b61c96ebe5afe\nBlock mined: 00c8327f367e43fcf9d129a5f6282c2458a8baa765a92afbff3847724f6287ac\n\nBalance Alice: 75\nBalance Bob: 125\n\n\n\nzcoin.isValid()\n\nTrue"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#digital-signature",
    "href": "posts/en/blockchain_1/index.html#digital-signature",
    "title": "Make your own blockchain",
    "section": "Digital signature",
    "text": "Digital signature\npip install eciespy\n\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n\nPrivate:  87d8dee553a45e174be1f39d05b5a40e4f24d8aa6dfc8f8ceaa2753751bd0123\nPublic:  0272ec1b8fe16cec26ae254009ef1cd9cf5b3f9fdc969b419004e5aedacd511210\n\n\n\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\nTrue\n0272ec1b8fe16cec26ae254009ef1cd9cf5b3f9fdc969b419004e5aedacd511210"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#transactions-1",
    "href": "posts/en/blockchain_1/index.html#transactions-1",
    "title": "Make your own blockchain",
    "section": "Transactions",
    "text": "Transactions\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#block-1",
    "href": "posts/en/blockchain_1/index.html#block-1",
    "title": "Make your own blockchain",
    "section": "Block",
    "text": "Block\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ])"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#blockchain-1",
    "href": "posts/en/blockchain_1/index.html#blockchain-1",
    "title": "Make your own blockchain",
    "section": "Blockchain",
    "text": "Blockchain\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True"
  },
  {
    "objectID": "posts/en/blockchain_1/index.html#test-1",
    "href": "posts/en/blockchain_1/index.html#test-1",
    "title": "Make your own blockchain",
    "section": "Test",
    "text": "Test\n\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n\nMy address: 032fdc54ce91b789d9525cbfc9c8661e9f00b6cef2eb37e52a22f4687f3bedb822\nAlice address: 02f6dbaf69c7a9cc53ca3a71c1936715a24cf7c7b759b01ee6be374d9935551ded\nBob address: 02f1d44e43da4034ee0dc51e9712155a11eb14081dcc0ba0bf3b5c1aed6ed90c33\n\n\n\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00ff4f95dcf593f48cbe416e77bb3f78fe7f44438c79163ee1d5c8ab844285c1\nMy balance: 100\n\n\n\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00103396896dcc7494efa26116ca9852af780ed22987bcdea49aaf2cfed6ca3c\nMy balance: 25"
  },
  {
    "objectID": "posts/en/fem/index.html",
    "href": "posts/en/fem/index.html",
    "title": "Finite Element Method",
    "section": "",
    "text": "The finite element method is a numerical technique used to solve complex engineering and physical problems. It is a powerful tool that allows for the accurate prediction of the behavior of a system under a wide range of conditions, making it an essential tool for engineers and scientists working in fields such as structural analysis, fluid dynamics, and electromagnetics. In this blog post, we will explore the basics of the finite element method and how it is used to solve real-world problems using Python. Whether you are an experienced engineer or a curious learner, I hope that this post will provide you with a better understanding of this important and versatile method.\nBy the end of this tutorial, you will be able to use Python to implement the finite element method and apply it to solve simple problems.\nAll the code can be found here."
  },
  {
    "objectID": "posts/en/fem/index.html#requirements",
    "href": "posts/en/fem/index.html#requirements",
    "title": "Finite Element Method",
    "section": "Requirements",
    "text": "Requirements\nTo run this code some libraries are required:\n\n\nTerminal\n\npip install numpy\n\n\n\nTerminal\n\npip install pygmsh\n\n\n\nTerminal\n\npip install gmsh\n\n\n\nTerminal\n\npip install pyglet\n\nTo start we must import some libraries, including numpy, pygmsh, drawMesh and gmsh. NumPy is a library for scientific computing in Python, and is often used for numerical calculations and data manipulation. The math library provides mathematical functions. The library drawMesh is a simple mesh visualization library based on pyglet developed for this project, it can be found in the github repository. Finally, gmsh is a powerful mesh generation software that can be used in conjunction with pygmsh. Together, these libraries provide the tools necessary to implement the finite element method in Python.\n\nimport numpy as np\nfrom math import *\nimport drawMesh\nimport pygmsh\nimport gmsh"
  },
  {
    "objectID": "posts/en/fem/index.html#node",
    "href": "posts/en/fem/index.html#node",
    "title": "Finite Element Method",
    "section": "Node",
    "text": "Node\nThe following code defines the Node class, which represents a node in a mesh. The class has several attributes and methods that are used to store and manipulate information about the node, such as its coordinates, forces, and displacements.\n\n\n\n\n\nThe init method is used to initialize a new Node object, and accepts the node’s id, x and y coordinates as arguments. The fx and fy attributes are used to store the external forces applied to the node, and the rx and ry attributes are used to store the reaction forces at the node. The dx and dy attributes are used to store the displacements of the node.\nThe dfix property returns a boolean value indicating whether the node is fixed in both x and y directions. The externalForce property returns a boolean value indicating whether the node has any external forces applied to it. The __eq__ method is used to compare two Node objects and returns a boolean value indicating whether they are at the same location. This class can be used to represent nodes in a mesh and perform operations on them.\n\nclass Node:\n    \n    def __init__(self, id, x, y):\n        self.id = id\n        self.x, self.y = x, y\n        self.fx, self.fy = 0.0, 0.0\n        self.rx, self.ry = 0.0 ,0.0\n        self.dx, self.dy = None, None\n        \n    @property\n    def dfix(self):\n        if self.dx == 0.0 and self.dy == 0.0:\n            return True\n        else:\n            return False\n        \n    @property\n    def externalForce(self):\n        if self.fx != 0.0 or self.fy != 0.0:\n            return True\n        else:\n            return False\n        \n    def __eq__(self, obj):\n        if (self.x == obj.x) and (self.y == obj.y):\n            return True\n        else:\n            return False"
  },
  {
    "objectID": "posts/en/fem/index.html#element",
    "href": "posts/en/fem/index.html#element",
    "title": "Finite Element Method",
    "section": "Element",
    "text": "Element\nEach element contains a series of nodes. In this case, we are using triangular nodes therefore each element has three nodes. It is important for the calculations that the nodes in each element are ordered counter-clockwise, therefore the passed nodes in the initialization are ordered with the orderCounterClock() method. The getArea()method calculates the area of the element. Each element contains a stress (\\(\\vec{\\sigma}\\)) and a strain (\\(\\vec{\\varepsilon}\\)) attributes:\n\\[\n\\vec{\\sigma} =  \\begin{bmatrix} \\sigma_{xx}\\\\ \\sigma_{yy}\\\\ \\sigma_{xy}\\\\ \\end{bmatrix} \\hspace{10mm} \\vec{\\varepsilon} =  \\begin{bmatrix} \\varepsilon_{xx}\\\\ \\varepsilon_{yy}\\\\ \\gamma_{xy}\\\\ \\end{bmatrix}\n\\]\nThe getColormethod takes the colorVal variable and returns a RGB color taking in account the maximum and minimum colorVal of the elements. The colorFuncis used to interpolate the colors and the values, by default it is a linear function, but in some cases it may be useful to have a logarithmic interpolation instead for example.\n\nclass Element:\n    \n    maxColorVal = -9.9e19\n    minColorVal = 9.9e19\n    colorFunc = lambda x: x\n    \n    def __init__(self, id, nodes):\n        self.id = id\n        self.nodes = self.orderCounterClock(nodes)\n        self.stress = None\n        self.strain = None\n        self.colorVal = 0\n        self.getArea()\n    \n    @property\n    def getmaxColorVal(self):\n        return Element.maxColorVal\n    \n    @property\n    def getminColorVal(self):\n        return Element.minColorVal\n    \n    @property\n    def getcolorFunc(self):\n        return Element.colorFunc\n\n    def getde(self):\n        de_ = []\n        for n in self.nodes:\n            de_.append(n.dx)\n            de_.append(n.dy)\n        self.de = np.array(de_)\n        return self.de\n    \n    def getColor(self):\n        \n        try: x_ = float(self.colorVal - Element.minColorVal)/(Element.maxColorVal - Element.minColorVal)\n        except ZeroDivisionError: x_ = 0.5 # cmax == cmin\n        \n        x = Element.colorFunc(x_)\n        \n        blue  = int(255* min((max((4*(0.75-x), 0.)), 1.)))\n        red   = int(255* min((max((4*(x-0.25), 0.)), 1.)))\n        green = int(255* min((max((4*fabs(x-0.5)-1., 0.)), 1.)))\n        return (red, green, blue)\n    \n    def getArea(self):\n        x1,y1 = self.nodes[0].x, self.nodes[0].y\n        x2,y2 = self.nodes[1].x, self.nodes[1].y\n        x3,y3 = self.nodes[2].x, self.nodes[2].y\n        result = 0.5*((x2*y3 - x3*y2)-(x1*y3- x3*y1)+(x1*y2-x2*y1))\n        if result == 0:\n            result = 1e-20\n        self.area = result\n        return result\n    \n    def getBe(self):\n        x1,y1 = self.nodes[0].x, self.nodes[0].y\n        x2,y2 = self.nodes[1].x, self.nodes[1].y\n        x3,y3 = self.nodes[2].x, self.nodes[2].y\n        B = (0.5/self.area) * np.array([\n            [(y2-y3) ,  0    , (y3-y1),  0   ,   (y1-y2),   0   ],\n            [   0    , (x3-x2),  0    , (x1-x3),     0   ,(x2-x1)],\n            [(x3-x2) , (y2-y3), (x1-x3), (y3-y1), (x2-x1) ,(y1-y2)],\n        ], dtype=np.float64)\n        self.Be = B\n        return B\n        \n    def getKe(self, D):\n        Bie = self.getBe()\n        Ke = self.area* np.matmul(Bie.T, np.matmul(D, Bie))\n        self.Ke = Ke\n        return Ke\n    \n    def orderCounterClock(self, nodes):\n        p1,p2,p3 = nodes[0], nodes[1], nodes[2]\n        val = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y)\n        nodes_ = nodes.copy()\n        if val > 0:\n            nodes[1] = nodes_[0]\n            nodes[0] = nodes_[1]   \n        \n        assembly = []\n        for n in nodes:\n            assembly.append(int(n.id*2))\n            assembly.append(int(n.id*2) +1)\n        self.assembly = assembly\n        \n        return nodes    \n\nIt is important to make the distinction between global and local variables and clarify the notation. Element numbers are denoted with a superscript and node numbers are denoted with a subscript. When a variable does not have a superscript is a global variable. For example, the local point \\(0\\) of the element number \\(4\\) is denoted as \\(P_0^{(4)}\\). Note the difference between a local and global point, \\(P_0^{e} \\ne P_0\\).\nThe force-displacement equation for an element is: \\(\\mathbf{K^e} \\mathbf{d^e} = \\mathbf{f^e} + \\mathbf{r^e}\\), where the displacements vector (\\(\\mathbf{d^e}\\)), and stiffness matrix (\\(\\mathbf{K^e}\\)) have the following form:\n\\[\\begin{equation}\n\n\\mathbf{d^e} =  \\begin{bmatrix}\nd_{0,x}^e\\\\\nd_{0,y}^e\\\\\nd_{1,x}^e\\\\\nd_{1,y}^e\\\\\nd_{2,x}^e\\\\\nd_{2,y}^e\\\\\n\\end{bmatrix}\n\n\\hspace{10mm}\n\n\\mathbf{K^e} = \\begin{bmatrix}\nk_{00} & k_{01} & k_{02} & k_{03} & k_{04} & k_{05} & \\\\\nk_{10} & k_{11} & k_{12} & k_{13} & k_{14} & k_{15} & \\\\\nk_{20} & k_{21} & k_{22} & k_{23} & k_{24} & k_{25} & \\\\\nk_{30} & k_{31} & k_{32} & k_{33} & k_{34} & k_{35} & \\\\\nk_{40} & k_{41} & k_{42} & k_{43} & k_{44} & k_{45} & \\\\\nk_{50} & k_{51} & k_{52} & k_{53} & k_{54} & k_{55} & \\\\\n\\end{bmatrix}\n\n\\end{equation}\\]\nThe stiffness matrix for each element can be obtained deriving the weak form of the elasticity problem (see Fish and Belytschko 2007, 227), resulting in the following equation: \\[\n\\mathbf{K^e} = \\int_{\\Omega}(\\mathbf{B^e})^T \\mathbf{D} \\hspace{1mm} \\mathbf{B^e} d \\Omega\n\\] The Hookean matrix \\(\\mathbf{D}\\) will be discussed later on, but basically, it relates the strain and stresses taking in account the material properties. The matrix \\(\\mathbf{B^e}\\) is a bit more complex, but the main thing to understand is that it relates the displacements at the nodes of an element to the gradient of the displacement function \\(\\theta^e(x,y)\\) (see Fish and Belytschko 2007, 78–84).\n\\[\n\\nabla \\theta^e = \\mathbf{B}^e \\mathbf{d}^e\n\\]\nThe displacement function can be understood as an interpolation of the node displacements across the space of the element. This can be any arbitrary polynomial function such that at the nodes the function matches the displacement, and that the continuity condition is meet at the boundaries of the elements.\n\\[\n\\theta^e(x_0,y_0) = \\begin{bmatrix} d_{x,0} \\\\ d_{y,0}\\end{bmatrix}\n\\]\n\n\n\n\n\nFor simplification purposes in this tutorial we will use a three-node linear function which yields the following formula to construct the \\(\\mathbf{B^e}\\) matrix (see Fish and Belytschko 2007, 160).\n\\[\\begin{equation}\n\\mathbf{B^e} =  \\frac{1}{2 A^e} \\begin{bmatrix}\n(y_1^e - y_2^e) & 0 & (y_2^e - y_0^e) & 0 & (y_0^e - y_1^e) & 0 & \\\\\n0 & (x_2^e - x_1^e) & 0 & (x_0^e - x_2^e) & 0 & (x_1^e - x_0^e) & \\\\\n(x_2^e - x_1^e) & (y_1^e - y_2^e) & (x_0^e - x_2^e) & (y_2^e - y_0^e) & (x_1^e - x_0^e) & (y_0^e - y_1^e) & \\\\\n\\end{bmatrix}\n\\end{equation}\\]\nThis choice of the linear function results in a \\(\\mathbf{B^e}\\) matrix that is constant along the surface (\\(\\Omega\\)) of the element, therefore we can simplify the weak form equation to obtain the element stiffness matrix:\n\\[\n\\mathbf{K^e} = (\\mathbf{B^e})^T \\mathbf{D} \\hspace{1mm} \\mathbf{B^e}\n\\]"
  },
  {
    "objectID": "posts/en/fem/index.html#extracting-mesh-data",
    "href": "posts/en/fem/index.html#extracting-mesh-data",
    "title": "Finite Element Method",
    "section": "Extracting mesh data",
    "text": "Extracting mesh data\nThe mesh contains points and cells data. Each data row in the cells array contains the index of the three points of a cell or element.\n\\[\n\\textbf{cells} = \\begin{bmatrix} P_0^{(0)} & P_1^{(0)} & P_2^{(0)} \\\\  P_0^{(1)} & P_1^{(1)} & P_2^{(1)} \\\\ \\vdots & \\vdots & \\vdots \\\\ P_0^{(N_{el})} & P_1^{(N_{el})} & P_2^{(N_{el})} \\\\ \\end{bmatrix} \\hspace{10mm}   \\textbf{points} =   \\begin{bmatrix} P_0 \\\\ P_1 \\\\ \\vdots \\\\ P_{N_{n}} \\end{bmatrix} \\hspace{10mm}           P_i =  \\begin{bmatrix} x_i & y_i \\end{bmatrix}\n\\]\n\n\\(N_{el}\\) : Number of elements\n\\(N_{n}\\) : Number of nodes (or points)\n\nBecause of how the pygmsh library works, the mesh starts counting points including some points like the center of the circle that are not exported to the mesh. Therefore the numbering of the nodes must be modified so that the first point in the mesh is numbered as \\(0\\):\n\nmaxNode = 0\nfor cell in mesh.cells[1].data:\n    for node in cell:\n        if node > maxNode:\n            maxNode = node\n\nmeshCells = mesh.cells[1].data - np.full(np.shape(mesh.cells[1].data), 1, dtype=np.uint64)\nmeshPoints = mesh.points[1:]\n\nNext, the elements and nodes are generated and stored in the lists elements and nodesrespectively:\n\nnodes = [Node(i, point[0], point[1]) for i, point in enumerate(meshPoints)]\nelements = []\n\nfor i,cell in enumerate(meshCells):\n    elements.append(\n        Element(id=i, nodes=[nodes[i] for i in cell])\n    )"
  },
  {
    "objectID": "posts/en/fem/index.html#material-properties",
    "href": "posts/en/fem/index.html#material-properties",
    "title": "Finite Element Method",
    "section": "Material properties",
    "text": "Material properties\nAs mentioned before the \\(\\mathbf{D}\\) matrix relates the stress and strains of an element. The Hookean matrix can be calculated with the Young’s modulus (\\(E\\)) and Poisson’s ratio (\\(\\nu\\)):\n\\[\n\\mathbf{D} = \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1}{2}(1-\\nu) \\\\ \\end{bmatrix}\n\\]\nFor this example lets use the material properties of steel.\n\nv = 0.28        # Poisson ratio of steel\nE = 200.0e9     # Young modulus of steel\n\nD = (E/(1-v**2)) * np.array([\n    [1, v, 0],\n    [v, 1, 0],\n    [0, 0, (1-v)/2],\n])"
  },
  {
    "objectID": "posts/en/fem/index.html#boundary-conditions",
    "href": "posts/en/fem/index.html#boundary-conditions",
    "title": "Finite Element Method",
    "section": "Boundary conditions",
    "text": "Boundary conditions\nOnce the mesh and material properties are defined the next step is to define the boundary conditions, external forces, reaction forces and unknowns. The unknown variables, i.e variables to solve for, are defined by assigning the None value. All the displacements are None by default, and all the external and reaction forces are 0.0 by default.\n\nfor i, node in enumerate(nodes):\n    if node.x == rect_length:           # At right side of the rectangle (x=10)\n        node.fx = 1.0e3                 # Apply a tension force in the x direction of 1kN\n    elif node.x == 0.0:                 # At left side of the rectangle (x=0)\n        node.dx, node.dy = 0.0, 0.0     # Fix the displacement in x and y\n        node.rx, node.ry = None, None   # Set the reaction forces as unknowns"
  },
  {
    "objectID": "posts/en/fem/index.html#von-mises-stress",
    "href": "posts/en/fem/index.html#von-mises-stress",
    "title": "Finite Element Method",
    "section": "von Mises stress",
    "text": "von Mises stress\nThe von Mises yield criterion is a very good way to estimate when an element will undergo plastic deformation by comparing the von Mises stress equivalent to the critical yield stress of the material. The von Mises equivalent stress can be calculated with the following equation: \\[\n\\sigma_v = \\sqrt{\\sigma_{xx} + \\sigma_{yy} + 3\\sigma_{xy}^2 - \\sigma_{xx}\\sigma_{yy} }\n\\]\n\ndef calculateVonMises(sx, sy, sxy):\n    return sqrt(sx**2 + sy**2 + 3*(sxy**2) - sx*sy)"
  },
  {
    "objectID": "posts/en/fem/index.html#visual-representation",
    "href": "posts/en/fem/index.html#visual-representation",
    "title": "Finite Element Method",
    "section": "Visual representation",
    "text": "Visual representation\nThe rgb function interpolates an input value between a maximum and minimum and returns a specific RGB color. The lower values are light blues and the higher are reds and yellows.\n\ndef rgb(mag, cmin, cmax):\n    try: x = float(mag-cmin)/(cmax-cmin)\n    except ZeroDivisionError: x = 0.5 \n    \n    blue  = int(255* min((max((4*(0.75-x), 0.)), 1.)))\n    red   = int(255* min((max((4*(x-0.25), 0.)), 1.)))\n    green = int(255* min((max((4*fabs(x-0.5)-1., 0.)), 1.)))\n    return (red, green, blue)\n\naverage = lambda x: (sum(x)/len(x))\n\nThe static attribute colorFunc of the Element class defines the function used to interpolate the values to the color. Here we set it to a linear function but it can be changed to an logarithmic function for example.\n\nmaxd, mind = max(d_total)[0], min(d_total)[0]\nElement.colorFunc = lambda x: x # Logarithmic: exp(-x)\n\nThe stresses are calculated using the generalized Hook’s expression. \\[\n\\varepsilon^e = \\mathbf{B}^e \\mathbf{d}^e \\hspace{20mm} \\sigma^e = \\mathbf{D} \\varepsilon^e\n\\]\nThe strains and stresses are calculated for each element and the color of each element is assigned depending on the value of the von Mises stress. The colorVal determines the value used for coloring, this can be modified so that the strains are colored instead for example.\n\nfor i,element in enumerate(elements):\n    \n    de = element.getde()\n    strain_e = np.matmul(element.Be, de)\n    stress_e = np.matmul(D, strain_e)\n    \n    element.strain = strain_e\n    element.stress = stress_e\n    \n    element.colorVal = calculateVonMises(element.stress[0], element.stress[1], element.stress[2])\n    \n    if element.colorVal > Element.maxColorVal:\n        Element.maxColorVal = element.colorVal\n    if element.colorVal < Element.minColorVal:\n        Element.minColorVal = element.colorVal\n\nFinally the results are viewed using the drawMesh module:\n\nrender = drawMesh.MeshRender()          # Creates an instance of a MeshRender\nrender.legend = True                    # The legened will be drawn\nrender.autoScale = True                 # The mesh will be automatically scaled to fit the window\nrender.deform_scale = 1.0e5             # Sets the scale to draw the deformation of the nodes displacement\nrender.legendTitle = 'von-mises (Pa)'\nrender.drawElements(elements)\n\n\n\n\n\n\nIf we rerun the code changing the force direction downwards we get the following result:\n\n\n\n\n\nThis particular problem of a plate with a hole in tension has been studied thoroughly due to its implications regarding riveting, aircraft pressurization and many other applications. There is an analytical expression to calculate the stresses in polar coordinates in a rectangular plate with a hole of radius \\(R\\) subjected to a tensional stress at both ends of \\(\\sigma_t\\):\n\\[\n\\sigma_r(r, \\theta) = \\frac{\\sigma_t}{2} \\left( 1- \\frac{R^2}{r^2} \\right) + \\frac{\\sigma_t}{2} \\left( 1 + 3\\frac{R^4}{r^4} - 4 \\frac{R^2}{r^2} \\right) \\cos(2\\theta)\n\\]\n\\[\n\\sigma_{\\theta}(r, \\theta) = \\frac{\\sigma_t}{2} \\left( 1 + \\frac{R^2}{r^2} \\right) - \\frac{\\sigma_t}{2} \\left( 1 + 3\\frac{R^4}{r^4} \\right) \\cos(2\\theta)\n\\]\n\\[\n\\tau_{r\\theta}(r, \\theta) = -\\frac{\\sigma_t}{2} \\left( 1 - 3\\frac{R^4}{r^4} + 2\\frac{R^2}{r^2} \\right) \\sin(2\\theta)\n\\]\nCalculating the von Mises stress and plotting the analytical expression using the same values as the example, yields the following result :\n\n\n\n\n\nWe can see that the results of the FEM method are the same as the predicted by the analytical method."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Finite Element Method\n\n\n\n\n\n\n\nPython\n\n\nFEM\n\n\n\n\n\n\n\n\n\n\n\nDec 7, 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nBlockchain, what is it?\n\n\n\n\n\n\n\nBlockchain\n\n\nCryptography\n\n\n\n\n\n\n\n\n\n\n\nNov 28, 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nMake your own blockchain\n\n\n\n\n\n\n\nPython\n\n\nBlockchain\n\n\nCryptography\n\n\n\n\n\n\n\n\n\n\n\nNov 20, 2022\n\n\nZee Marquez\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre mi",
    "section": "",
    "text": "¡Hola! Mi nombre es Zee Márquez y soy ingeniero mecánico. En este blog voy subiendo curiosidades, artículos y proyectos de temas que me llaman la atención. Entre los temas que abarco en este blog están el blockchain, simulación, optimización y más."
  }
]