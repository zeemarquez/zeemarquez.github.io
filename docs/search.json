[
  {
    "objectID": "posts/blockchain_0/index.html",
    "href": "posts/blockchain_0/index.html",
    "title": "Blockchain, ¿qué es eso?",
    "section": "",
    "text": "La wikipedia define blockchain como: “una etiqueta que a través de una estructura de datos cuya información se agrupa en conjuntos (bloques) a los que se les añade metainformaciones relativas a otro bloque de la cadena anterior en una línea temporal para hacer un seguimiento seguro a través de grandes cálculos criptográficos”. ¿Pero qué significa todo esto? La traducción literal de “blockchain” al español es: “cadena de bloques”. Pero, ¿qué son estos “bloques”?, ¿y por qué están “encadenados”?.\nCuando hablamos de una cadena de bloques nos referimos a una serie de objetos, o bloques, que contienen una infromación, pero no son un grupo de objetos sin relacción entre ellos, sino que cada objeto hace referencia al anterior. Imaginemos por ejemplo un libro, al final podemos definir un libro como una cadena de paginas o “page-chain”, el libro solo tiene sentido si las paginas están ordenadas correctamente.\n\n\n\n\n\nEn una blockchain cada bloque sería como una pagina de un libro que hace referencia a la pagina anterior. Vale pero esto para qué sirve."
  },
  {
    "objectID": "posts/blockchain_0/index.html#función-hash",
    "href": "posts/blockchain_0/index.html#función-hash",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Función hash",
    "text": "Función hash\ngenerador hash"
  },
  {
    "objectID": "posts/blockchain_0/index.html#firma-digital",
    "href": "posts/blockchain_0/index.html#firma-digital",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Firma digital",
    "text": "Firma digital"
  },
  {
    "objectID": "posts/blockchain_1/index.html",
    "href": "posts/blockchain_1/index.html",
    "title": "Crea tu propia blockchain",
    "section": "",
    "text": "import hashlib as hs\nimport time\n\nFirst we will create a\n\n\n\n\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n\n\n\n\n\n\n\n\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n        \n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #La direccion desde donde se manda la recompensa de minar\n    \n    def __init__(self):\n        self.difficulty = 2         #El numero de ceros por el que empieza el hash del nuevo bloque\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n        \n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True\n\n\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n\nBlock mined: 00d3103ff5c39cb5a767d1aeb7c7ffc6688d3542c6010931b1a3678394864024\nBlock mined: 00c0aa613e85c91753ada9d17af985dd399f035af6726d41b228c12289867c05\n\nBalance Alice: 75\nBalance Bob: 125\n\n\n\nzcoin.isValid()\n\nTrue\n\n\npip install eciespy\n\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n\nPrivate:  e4c871e8286b78df6cd630c28e125e02f2a16ff87dcd912e62bb261c563bbb2c\nPublic:  039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64\n\n\n\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\nTrue\n039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64\n\n\n\nSecure Blockchain\nNow we will implement the secure blockchain\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)\n\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ]) \n\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True\n\n\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n\nMy address: 0215ed3b39244e195468374ab6bb55b50aa8f38276f7d7d7b94c876dd8ea278f68\nAlice address: 02eb29d61de4df9822bfa8acffc3d10640edb49f1cb76147b64fef322580ceb96e\nBob address: 027cfa0eef6c57044baf03b19b6c444b65c40c06f867131c384695281d5464e039\n\n\n\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00eadfbfe69c18d11cc1d261bfe632a5e9ee6f3468811fb30222ae697c6acffa\nMy balance: 100\n\n\n\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00cf117bec10fc2d03ba9b395d5f24eaacf6f55c75d647d58471805019cb471e\nMy balance: 25"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Crea tu propia blockchain\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\n18 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nBlockchain, ¿qué es eso?\n\n\n\n\n\n\n\ncode\n\n\nblockchain\n\n\n\n\n\n\n\n\n\n\n\n10 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre mi",
    "section": "",
    "text": "About this blog"
  }
]