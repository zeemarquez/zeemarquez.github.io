[
  {
    "objectID": "posts/blockchain_0/index.html",
    "href": "posts/blockchain_0/index.html",
    "title": "Blockchain, ¿qué es eso?",
    "section": "",
    "text": "La wikipedia define blockchain como: “una etiqueta que a través de una estructura de datos cuya información se agrupa en conjuntos (bloques) a los que se les añade metainformaciones relativas a otro bloque de la cadena anterior en una línea temporal para hacer un seguimiento seguro a través de grandes cálculos criptográficos”. ¿Pero qué significa todo esto? La traducción literal de “blockchain” al español es: “cadena de bloques”. Pero, ¿qué son estos “bloques”?, ¿y por qué están “encadenados”?.\nCuando hablamos de una cadena de bloques nos referimos a una serie de objetos, o bloques, que contienen una infromación, pero no son un grupo de objetos sin relacción entre ellos, sino que cada objeto hace referencia al anterior. Imaginemos por ejemplo un libro, al final podemos definir un libro como una cadena de paginas o “page-chain”, el libro solo tiene sentido si las paginas están ordenadas correctamente.\n\n\n\n\n\nEn una blockchain cada bloque sería como una pagina de un libro que hace referencia a la pagina anterior. Vale pero esto para qué sirve."
  },
  {
    "objectID": "posts/blockchain_0/index.html#función-hash",
    "href": "posts/blockchain_0/index.html#función-hash",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Función hash",
    "text": "Función hash\nLa función hash es una de las herramientas criptograficas más importantes y es imprescindible para crean una blockchain. Aunque el funcionamiento de una función hash puede ser muy complicado el concepto es bastante simple. Se trata de una función que convierte una entrada (la palabla “hola” por ejemplo) en un a salida que parece aleatoria.\n\n\n\n\n\nLo que hace a la función hash tan util es que siempre devuelve un resultado del mismo tamaño. Existen muchos tipos de algoritmos hash diferentes, uno de los mas usado es el SHA256, que devuelve 256 bits. Da igual que la entrada de la función sea la letra “a” o el Quijote entero, siempre el resultado son 256 bits. Prueba a experimentar con la función hash:\n#| standalone: true\nimport hashlib as hs\nfrom shiny import *\n\napp_ui = ui.page_fluid(\n  ui.tags.style(\n        \"\"\"\n        .app-col {\n            border: 1px solid white;\n            border-radius: 5px;\n            background-color: #ffffff;\n            padding: 8px;\n            margin-top: 5px;\n            margin-bottom: 2px;\n        }\n        \"\"\"\n    ),\n  \n  ui.row(\n    ui.div(\n                {\"class\": \"app-col\"},\n                ui.p(\n                    ui.input_text(\"x\", \"\", placeholder=\"hola\"), \n                ),\n                ui.p(\n                    ui.output_text(\"txt\"),\n                ),\n            ),\n            align=\"center\",\n)\n)\n\ndef server(input, output, session):\n  @output\n  @render.text\n  def txt():\n    if len(input.x()) == 0:\n      hash = hs.sha256((\"hola\").encode()).hexdigest()\n    else:\n      hash = hs.sha256((input.x()).encode()).hexdigest()\n    return f'{hash}'\n\n\napp = App(app_ui, server, debug=True)\n\nLa función hash es caotica, que quiere decir que un minusculo cambio a la entrada (por ejemplo poner la “h” en mayuscula) provoca un resultado completamente diferente. Es importante distinguir caotico de aleatorio, la función hash no es aleatoria, es determinista, siempre devolverá la misma salida a la misma entrada. Se podría comparar la función hash con el doble péndulo, otro ejemplo de sistema caotico. Cambiar un poquito las condiciones iniciales del doble pendulo provoca resultados de movimiento completamente diferentes. En el ejemplo inferior parece que los dos pendulos son iguales al principio, pero en realidad tienen un cambio despreciable en el angulo inicial, pero este minusculo cambio es suficiente para alterar por completo el resultado.\n\n\n\n\n\n\n\n\n\n\nOtra caracteristica del sistema de doble pendulo es que pasado un tiempo es practicamente imposible deducir el estado inicial del pendulo. De la misma forma, es imposible conocer que entrada a la función hash dará un resultado especifico, o en otras palabras, es imposible hacer la función hash al reves. La unica forma de saber que resultado dará una entrada es realizando la función hash sobre esa entrada.\nSi recuerdas los problemas mencionados antes, la función hash resuleve uno de los problemas: codificar la información de cada página (o bloque) de una forma única, determinista y con un tamaño fijo. De esta forma los bloques se “encadenan” porque cada bloque contiene el hash del bloque anterior.\n\n\n\n\n\nLa función hash también nos permite implementar la prueba de trabajo. Computar la función hash requiere una cantidad de tiempo. Como podias ver en la función hash interactiva de antes, no se tarda mucho en calcular, pero si se ejecuta varias veces se empieza a notar. Para implementar la prueba de trabajo en una blockchain podemos, por ejemplo, añadir una variable libre (nonce) a la entrada de la funcion hash y exigir que el hash de cada bloque empieze por \"0000\". Como es imposible saber que entrada resultara en un hash que comienze por \"0000\", la unica forma es probar y probar hasta acertar. Este proceso de probar miles de entradas posibles para la función hash requiere computación y tiempo. Por ejemplo, usando la palabra \"hola\" como entrada del hash, probamos \"hola_0\", \"hola_1\", \"hola_2\"… Al final después de un tiempo resolvemos la prueba de trabajo, si se hashea \"hola_167537\"obtenemos:\n0000c24a5157df9c08de36972e30404e463b1e76bbb25007395d455b9494ad77\""
  },
  {
    "objectID": "posts/blockchain_0/index.html#firma-digital",
    "href": "posts/blockchain_0/index.html#firma-digital",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Firma digital",
    "text": "Firma digital"
  },
  {
    "objectID": "posts/blockchain_1/index.html",
    "href": "posts/blockchain_1/index.html",
    "title": "Crea tu propia blockchain",
    "section": "",
    "text": "import hashlib as hs\nimport time\n\nFirst we will create a\n\n\n\n\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n\n\n\n\n\n\n\n\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n        \n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #La direccion desde donde se manda la recompensa de minar\n    \n    def __init__(self):\n        self.difficulty = 2         #El numero de ceros por el que empieza el hash del nuevo bloque\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n        \n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True\n\n\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n\nBlock mined: 00d3103ff5c39cb5a767d1aeb7c7ffc6688d3542c6010931b1a3678394864024\nBlock mined: 00c0aa613e85c91753ada9d17af985dd399f035af6726d41b228c12289867c05\n\nBalance Alice: 75\nBalance Bob: 125\n\n\n\nzcoin.isValid()\n\nTrue\n\n\npip install eciespy\n\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n\nPrivate:  e4c871e8286b78df6cd630c28e125e02f2a16ff87dcd912e62bb261c563bbb2c\nPublic:  039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64\n\n\n\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\nTrue\n039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64\n\n\n\nSecure Blockchain\nNow we will implement the secure blockchain\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)\n\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ]) \n\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True\n\n\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n\nMy address: 0215ed3b39244e195468374ab6bb55b50aa8f38276f7d7d7b94c876dd8ea278f68\nAlice address: 02eb29d61de4df9822bfa8acffc3d10640edb49f1cb76147b64fef322580ceb96e\nBob address: 027cfa0eef6c57044baf03b19b6c444b65c40c06f867131c384695281d5464e039\n\n\n\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00eadfbfe69c18d11cc1d261bfe632a5e9ee6f3468811fb30222ae697c6acffa\nMy balance: 100\n\n\n\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00cf117bec10fc2d03ba9b395d5f24eaacf6f55c75d647d58471805019cb471e\nMy balance: 25"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Crea tu propia blockchain\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\n18 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nBlockchain, ¿qué es eso?\n\n\n\n\n\n\n\ncode\n\n\nblockchain\n\n\n\n\n\n\n\n\n\n\n\n10 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre mi",
    "section": "",
    "text": "About this blog"
  }
]