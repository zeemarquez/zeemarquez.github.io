[
  {
    "objectID": "posts/blockchain_0/index.html",
    "href": "posts/blockchain_0/index.html",
    "title": "Blockchain, ¿qué es eso?",
    "section": "",
    "text": "En este post intento explicar lo que es una blockchain de la forma más simple, visual e interactiva posible. No es necesario tener conocimientos de programación o criptografía para entender como funciona una blockchain. Si quieres entrar más en detalle tengo otro post explicando como programar una blockchain en Python desde cero."
  },
  {
    "objectID": "posts/blockchain_0/index.html#función-hash",
    "href": "posts/blockchain_0/index.html#función-hash",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Función hash",
    "text": "Función hash\nLa función hash es una de las herramientas criptográficas más importantes y es imprescindible para crear una blockchain. Aunque el funcionamiento interno de una función hash puede ser muy complicado, el concepto es bastante simple. Se trata de una función que convierte una entrada (la palabra “hola” por ejemplo) en un a salida que a priori parece aleatoria, aunque no lo es.\n\n\n\n\n\nLo que hace a la función hash tan útil es que siempre devuelve un resultado del mismo tamaño. Existen muchos tipos de algoritmos hash diferentes, uno de los mas usados es el SHA256, que devuelve 256 bits. Da igual que la entrada de la función sea la letra “a” o el Quijote entero, siempre el resultado son 256 bits. A continuación, puedes probar a experimentar con la función hash:\n#| standalone: true\nimport hashlib as hs\nfrom shiny import *\n\napp_ui = ui.page_fluid(\n  ui.tags.style(\n        \"\"\"\n        .app-col {\n            border: 1px solid white;\n            border-radius: 5px;\n            background-color: #ffffff;\n            padding: 8px;\n            margin-top: 5px;\n            margin-bottom: 2px;\n        }\n        \"\"\"\n    ),\n  \n  ui.row(\n    ui.div(\n                {\"class\": \"app-col\"},\n                ui.p(\n                    ui.input_text(\"x\", \"\", placeholder=\"hola\",width=\"75%\"), \n                ),\n                ui.p(\n                    ui.output_text(\"txt\"),\n                ),\n            ),\n            align=\"center\",\n)\n)\n\ndef server(input, output, session):\n  @output\n  @render.text\n  def txt():\n    if len(input.x()) == 0:\n      hash = hs.sha256((\"hola\").encode()).hexdigest()\n    else:\n      hash = hs.sha256((input.x()).encode()).hexdigest()\n    return f'{hash}'\n\n\napp = App(app_ui, server, debug=True)\n\nLa función hash es caótica, es decir que un minúsculo cambio en la entrada (por ejemplo, poner la “h” en mayúscula) provoca un resultado completamente diferente. Es importante distinguir caótico de aleatorio, la función hash no es aleatoria, es determinista, siempre devolverá la misma salida a la misma entrada. Se podría comparar la función hash con el sistema de doble péndulo, otro ejemplo de sistema caótico. En un doble péndulo las entradas serian los ángulos iniciales de los péndulos, y la salida el movimiento resultante. Cambiar un poquito las condiciones iniciales del doble péndulo provoca resultados de movimiento completamente diferentes. En el ejemplo inferior parece que los dos péndulos empiezan igual al principio, pero en realidad tienen un cambio despreciable en el ángulo inicial, pero este minúsculo cambio es suficiente para alterar por completo el resultado.\n\n\n\n\n\n\n\n\n\n\nOtra característica del sistema de doble péndulo es que pasado un tiempo es prácticamente imposible deducir el estado inicial del péndulo. De la misma forma, es imposible conocer que entrada a la función hash dará un resultado especifico o, en otras palabras, es imposible hacer la función hash al revés. La única forma de saber que resultado dará una entrada es realizando la función hash sobre esa entrada.\nSi recuerdas los problemas mencionados antes, la función hash resuelve uno de los problemas: codificar la información de cada página (o bloque) de una forma única, determinista y con un tamaño fijo. De esta forma los bloques se “encadenan” porque cada bloque contiene el hash del bloque anterior. Como el hash del bloque anterior se incluye para obtener el hash del bloque posterior, modificar un solo número provoca cambios radicales en todos los hashes de los bloques posteriores, es decir: están encadenados.\n\n\n\n\n\nLa función hash también permite implementar la prueba de trabajo. Computar la función hash requiere una cantidad de tiempo. Como podías ver en la función hash interactiva de antes, no se tarda mucho en calcular, pero si se ejecuta millones de veces la cantidad de tiempo es significativa. Para implementar la prueba de trabajo en una blockchain podemos, añadir una variable libre (nonce) a la entrada de la función hash y exigir que el hash de cada bloque empiece por \"0000\". Como es imposible saber que entrada resultara en un hash que comience por \"0000\", la única forma es probar y probar hasta acertar. Este proceso de probar miles de entradas posibles para la función hash requiere computación y tiempo. Por ejemplo, usando la palabra \"hola\" como entrada del hash, probamos \"hola_0\", \"hola_1\", \"hola_2\"… Al final después de un tiempo resolvemos la prueba de trabajo, si probamos con \"hola_167537\"obtenemos el hash que comienza con 4 ceros:\n\n0000c24a5157df9c08de36972e30404e463b1e76bbb25007395d455b9494ad77"
  },
  {
    "objectID": "posts/blockchain_0/index.html#firma-digital",
    "href": "posts/blockchain_0/index.html#firma-digital",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Firma digital",
    "text": "Firma digital\nLa firma digital, como una firma real, nos permite marcar información de tal manera que cualquiera pueda comprobar que efectivamente, esa información firmada la hemos creado nosotros. Sin esta herramienta una criptomoneda no podría funcionar ya que cualquier miembro de la blockchain podría hacerse pasar por otra persona. Si nos paramos a pensar, qué es una firma, no es más que modificar un documento con una marca que solo la persona que firma puede hacer. El proceso de firmar un documento es bastante intuitivo, pero ¿cómo puede alguien comprobar que la firma es de verdad? Aquí es donde entra en juego la encriptación asimétrica. La encriptación no es más que el proceso de bloquear o esconder algo del acceso público. Las puertas normales de nuestras casas son un tipo de “encriptación” simétrica. Tenemos una llave que es la misma que cierra o abre la puerta, es decir, el proceso de abrir es simétrico al de cerrar. Lo mismo pasa con los candados de la bici o las taquillas. En cambio, en una encriptación asimétrica hay dos llaves: una que cierra y otra que abre. Si nuestras casas tuvieran puertas asimétricas necesitaríamos una llave diferente para abrir la puerta que para cerrarla. Parece complicarse para nada, pero esto es extremadamente útil para las firmas digitales.\n\n\nEncriptación asimetrica:\n\n\n\nEn una firma digital la llave de cerrar es la llave privada, y la de abrir la pública. La llave pública se genera a partir de la llave privada, pero es imposible conocer la llave privada sabiendo únicamente la pública. Digamos que Alicia tiene un par de llaves publica y privada y quiere firmar una carta. La pública la puede ver cualquiera, y la privada solo la conoce ella. Alicia encripta una carta usando su llave privada y se la manda a Juan. Recordemos que esa carta ahora únicamente se puede abrir con la llave pública de Alicia. Juan abre la carta con la llave publica de Alicia y de esta forma Juan sabe que esa carta la ha encriptado Alicia con su llave privada, sin tener que conocer cual es la llave privada de Alicia."
  },
  {
    "objectID": "posts/blockchain_1/index.html",
    "href": "posts/blockchain_1/index.html",
    "title": "Crea tu propia blockchain",
    "section": "",
    "text": "En este post explico como programar una blockchain, especificamente una criptomoneda, desde cero en Python. Te recomiendo que le eches un vistazo a mi otro post que explica el funcionamiento de una blockchain."
  },
  {
    "objectID": "posts/blockchain_1/index.html#transacciones",
    "href": "posts/blockchain_1/index.html#transacciones",
    "title": "Crea tu propia blockchain",
    "section": "Transacciones",
    "text": "Transacciones\n\n\n\n\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n\n\n\n\n\n\n\n\nEmpezaremos creando la clase Transaction. Los objetos de este tipo recogen las propiedades de las transacciones, estas son el emisor, receptor y valor de la transacción:\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value"
  },
  {
    "objectID": "posts/blockchain_1/index.html#bloque",
    "href": "posts/blockchain_1/index.html#bloque",
    "title": "Crea tu propia blockchain",
    "section": "Bloque",
    "text": "Bloque\n\n\n\n\nclassDiagram\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n\n\n\n\n\n\n\n\nDefinimos una clase Block que representa cada bloque de la blockchain. Los bloques tiene como atributos: el conjunto de transacciones (transactions), el sello temporal (timestamp) que indica cuando se creo el bloque, el hash del bloque anterior (prevHash), el hash del bloque (hash) y la variable libre (nonce). La función calculateHash() calcula el hash del bloque usando el algoritmo SHA256 y tomando como entrada los atributos del bloque. La función mineBlock(difficulty) ejecuta la prueba de trabajo en un bucle que incrementa la variable nonce hasta que encuentra el hash correspondiente que comienza con el numero de ceros especificado por la dificultad de minado.\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)"
  },
  {
    "objectID": "posts/blockchain_1/index.html#blockchain",
    "href": "posts/blockchain_1/index.html#blockchain",
    "title": "Crea tu propia blockchain",
    "section": "Blockchain",
    "text": "Blockchain\n\n\n\n\nclassDiagram\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n\n\n\n\n\n\n\n\nLa clase Blockchain tiene como atributos la difficultad de mindao, la recompensa de minado, la lista chain que contiene los bloques y la lista de transacciones pendientes para añadir al siguiente bloque. Al inicializar un objeto Blockchain se crea el bloque genesis (createGenBlock()). La función addBlock(newBlock) añade un nuevo bloque a la cadena obteniendo el hash del ultimo bloque y minando el nuevo bloque. La función minePending(minnerAddress) coge las transacciones pendientes y añade la transacción de recompensa de minado. Posteriormente crea un nuevo bloque, ejecuta la función addBlock(newBlock) con el nuevo bloque creado y vacia la lista de transacciones pendientes.\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #La direccion desde donde se manda la recompensa de minar\n    \n    def __init__(self):\n        self.difficulty = 2         #El numero de ceros por el que empieza el hash del nuevo bloque\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True"
  },
  {
    "objectID": "posts/blockchain_1/index.html#prueba",
    "href": "posts/blockchain_1/index.html#prueba",
    "title": "Crea tu propia blockchain",
    "section": "Prueba",
    "text": "Prueba\n\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n\nBlock mined: 007277ad9cf1a1dca10f0201c4b32bb2bb2cd198f9ef024b2bc39a80360716b5\nBlock mined: 00e2158cfb1f6986161857e7ad8bea85cd300d0f6fd4fa2b3382a0eed6fa78ea\n\nBalance Alice: 75\nBalance Bob: 125\n\n\n\nzcoin.isValid()\n\nTrue"
  },
  {
    "objectID": "posts/blockchain_1/index.html#firma-digital",
    "href": "posts/blockchain_1/index.html#firma-digital",
    "title": "Crea tu propia blockchain",
    "section": "Firma digital",
    "text": "Firma digital\npip install eciespy\n\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n\nPrivate:  bea7d97393649bde46ba480f3525bd20e80cb4c03ddc5fc3c032f60e1a1f16ae\nPublic:  0210730f68e5ee879de88c5dffc59fe2f6f5fb6224d777df3936e4a28be507420f\n\n\n\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\nTrue\n0210730f68e5ee879de88c5dffc59fe2f6f5fb6224d777df3936e4a28be507420f"
  },
  {
    "objectID": "posts/blockchain_1/index.html#transacciones-1",
    "href": "posts/blockchain_1/index.html#transacciones-1",
    "title": "Crea tu propia blockchain",
    "section": "Transacciones",
    "text": "Transacciones\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)"
  },
  {
    "objectID": "posts/blockchain_1/index.html#bloque-1",
    "href": "posts/blockchain_1/index.html#bloque-1",
    "title": "Crea tu propia blockchain",
    "section": "Bloque",
    "text": "Bloque\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ])"
  },
  {
    "objectID": "posts/blockchain_1/index.html#blockchain-1",
    "href": "posts/blockchain_1/index.html#blockchain-1",
    "title": "Crea tu propia blockchain",
    "section": "Blockchain",
    "text": "Blockchain\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True"
  },
  {
    "objectID": "posts/blockchain_1/index.html#prueba-1",
    "href": "posts/blockchain_1/index.html#prueba-1",
    "title": "Crea tu propia blockchain",
    "section": "Prueba",
    "text": "Prueba\n\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n\nMy address: 03c96502f32ef144d419cc758a0da0de465eebb592b3589bcebb013794d0a300d8\nAlice address: 0349de61e8f48c03d30fbfd21b5f4ac1ccbd5efe0f402014afdef407c96d633659\nBob address: 0210834527148b0a921a699d0571e95b16dfef757cdf1c0d8acf6e633956935a75\n\n\n\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00b855101a5d9524f68bef1f7f3f7c41bbe3887a34937f514eb7d13302cea389\nMy balance: 100\n\n\n\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 0054871538a7792aa2674186fdad43e2e69393bfd2b4fa1dc708f44b98424f8c\nMy balance: 25"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Finite Element Method\n\n\n\n\n\n\n\nPython\n\n\nFEM\n\n\n\n\n\n\n\n\n\n\n\n7 dic 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nBlockchain, ¿qué es eso?\n\n\n\n\n\n\n\nbitcoin\n\n\nblockchain\n\n\n\n\n\n\n\n\n\n\n\n28 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nCrea tu propia blockchain\n\n\n\n\n\n\n\npython\n\n\ncode\n\n\nblockchain\n\n\nbitcoin\n\n\n\n\n\n\n\n\n\n\n\n20 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre mi",
    "section": "",
    "text": "¡Hola! Mi nombre es Zee Márquez y soy ingeniero mecánico. Actualmente estoy estudiando un máster de ingeniería aeroespacial especializado en aerodinámica y energía eólica en TU Delft. En este blog voy subiendo curiosidades, artículos y proyectos de temas que me llaman la atención. Entre los temas que abarco en este blog están el blockchain, simulación, optimización y más."
  },
  {
    "objectID": "posts/fem/index.html",
    "href": "posts/fem/index.html",
    "title": "Finite Element Method",
    "section": "",
    "text": "The finite element method is a numerical technique used to solve complex engineering and physical problems. It is a powerful tool that allows for the accurate prediction of the behavior of a system under a wide range of conditions, making it an essential tool for engineers and scientists working in fields such as structural analysis, fluid dynamics, and electromagnetics. In this blog post, we will explore the basics of the finite element method and how it is used to solve real-world problems using Python. Whether you are an experienced engineer or a curious learner, I hope that this post will provide you with a better understanding of this important and versatile method.\nBy the end of this tutorial, you will be able to use Python to implement the finite element method and apply it to solve simple problems.\nAll the code can be find here."
  },
  {
    "objectID": "posts/fem/index.html#extract-mesh-data",
    "href": "posts/fem/index.html#extract-mesh-data",
    "title": "Finite Element Method",
    "section": "Extract mesh data",
    "text": "Extract mesh data\n\nmaxNode = 0\nfor cell in mesh.cells[1].data:\n    for node in cell:\n        if node > maxNode:\n            maxNode = node\n\nmeshCells = mesh.cells[1].data - np.full(np.shape(mesh.cells[1].data), 1, dtype=np.uint64)\nmeshPoints = mesh.points[1:]\n\n\nnodes = [Node(i, point[0], point[1]) for i, point in enumerate(meshPoints)]\nelements = []\n\nfor i,cell in enumerate(meshCells):\n    elements.append(\n        Element(id=i, nodes=[nodes[i] for i in cell])\n    )"
  },
  {
    "objectID": "posts/fem/index.html#material-properties",
    "href": "posts/fem/index.html#material-properties",
    "title": "Finite Element Method",
    "section": "Material properties",
    "text": "Material properties\n\nv = 0.28\nE = 200.0e9\n\nD = (E/(1-v**2)) * np.array([\n    [1, v, 0],\n    [v, 1, 0],\n    [0, 0, (1-v)/2],\n])"
  },
  {
    "objectID": "posts/fem/index.html#boundary-conditions-and-forces",
    "href": "posts/fem/index.html#boundary-conditions-and-forces",
    "title": "Finite Element Method",
    "section": "Boundary conditions and forces",
    "text": "Boundary conditions and forces\n\nfor i, node in enumerate(nodes):\n    if node.x == rect_length:           # At right side of the rectangle (x=10)\n        node.fx = 1.0e3                 # Apply a downwards force of 1kN\n    elif node.x == 0.0:                 # At left side of the rectangle (x=0)\n        node.dx, node.dy = 0.0, 0.0     # Fix the displacement in x and y\n        node.rx, node.ry = None, None   # Set the reaction forces as unknowns"
  },
  {
    "objectID": "posts/fem/index.html#von-mises-stress",
    "href": "posts/fem/index.html#von-mises-stress",
    "title": "Finite Element Method",
    "section": "Von-Mises Stress",
    "text": "Von-Mises Stress\n\\[\n\\sigma_v = \\sqrt{\\sigma_{xx} + \\sigma_{yy} + 3\\sigma_{xy}^2 - \\sigma_{xx}\\sigma_{yy} }\n\\]\n\ndef calculateVonMises(sx, sy, sxy):\n    return sqrt(sx**2 + sy**2 + 3*(sxy**2) - sx*sy)"
  },
  {
    "objectID": "posts/fem/index.html#mesh-deformation-and-coloring",
    "href": "posts/fem/index.html#mesh-deformation-and-coloring",
    "title": "Finite Element Method",
    "section": "Mesh deformation and Coloring",
    "text": "Mesh deformation and Coloring\n\ndef rgb(mag, cmin, cmax):\n    try: x = float(mag-cmin)/(cmax-cmin)\n    except ZeroDivisionError: x = 0.5 \n    \n    blue  = int(255* min((max((4*(0.75-x), 0.)), 1.)))\n    red   = int(255* min((max((4*(x-0.25), 0.)), 1.)))\n    green = int(255* min((max((4*fabs(x-0.5)-1., 0.)), 1.)))\n    return (red, green, blue)\n\naverage = lambda x: (sum(x)/len(x))\n\n\nmaxd, mind = max(d_total)[0], min(d_total)[0]\nElement.colorFunc = lambda x: x #exp(-x)\n\n\\[\n\\varepsilon^e = \\mathbf{B}^e \\mathbf{d}^e \\hspace{20mm} \\sigma^e = \\mathbf{D} \\varepsilon^e\n\\]\n\nfor i,element in enumerate(elements):\n    \n    de = element.getde()\n    strain_e = np.matmul(element.Be,de)\n    stress_e = np.matmul(D, strain_e)\n\n    dx_avg = average([de[0], de[2], de[4]])\n    dy_avg = average([de[1], de[3], de[5]])\n    \n    element.strain = strain_e\n    element.stress = stress_e\n    \n    element.colorVal = calculateVonMises(element.stress[0], element.stress[1], element.stress[2])\n    \n    if element.colorVal > Element.maxColorVal:\n        Element.maxColorVal = element.colorVal\n    if element.colorVal < Element.minColorVal:\n        Element.minColorVal = element.colorVal\n\n\nrender = drawMesh.MeshRender()\nrender.legend = True\nrender.autoScale = True\nrender.deform_scale = 1.0e5\nrender.legendDiscretize = 10\nrender.legendTitle = 'von-mises (Pa)'\nrender.drawElements(elements)\n\n\n\n\n\n\nIf we rerun the code changing the force direction downwards we get the following result:"
  },
  {
    "objectID": "posts/fem/index.html#element",
    "href": "posts/fem/index.html#element",
    "title": "Finite Element Method",
    "section": "Element",
    "text": "Element\nEach element contains a series of nodes. In this case, we are using triangular nodes therefore each element has three nodes. It is important for the calculations that the nodes in each element are ordered counter-clockwise, therefore the passed nodes in the initialization are ordered with the orderCounterClock() method. Each element contains a stress (\\(\\vec{\\sigma}\\)) and a strain (\\(\\vec{\\varepsilon}\\)) attributes:\n\\[\\begin{equation}\n\n\\vec{\\sigma} =  \\begin{bmatrix}\n\\sigma_{xx}\\\\\n\\sigma_{yy}\\\\\n\\sigma_{xy}\\\\\n\\end{bmatrix}\n\n\\hspace{10mm}\n\n\\vec{\\varepsilon} =  \\begin{bmatrix}\n\\varepsilon_{xx}\\\\\n\\varepsilon_{yy}\\\\\n\\gamma_{xy}\\\\\n\\end{bmatrix}\n\n\\end{equation}\\]\n\\[\\begin{equation}\n\\mathbf{d^e} =  \\begin{bmatrix}\nd_{0,x}^e\\\\\nd_{0,y}^e\\\\\nd_{1,x}^e\\\\\nd_{1,y}^e\\\\\nd_{2,x}^e\\\\\nd_{2,y}^e\\\\\n\\end{bmatrix}\n\n\\hspace{5mm}\n\n\\mathbf{K^e} = \\begin{bmatrix}\nk_{00} & k_{01} & k_{02} & k_{03} & k_{04} & k_{05} & \\\\\nk_{10} & k_{11} & k_{12} & k_{13} & k_{14} & k_{15} & \\\\\nk_{20} & k_{21} & k_{22} & k_{23} & k_{24} & k_{25} & \\\\\nk_{30} & k_{31} & k_{32} & k_{33} & k_{34} & k_{35} & \\\\\nk_{40} & k_{41} & k_{42} & k_{43} & k_{44} & k_{45} & \\\\\nk_{50} & k_{51} & k_{52} & k_{53} & k_{54} & k_{55} & \\\\\n\\end{bmatrix}\n\n\\end{equation}\\]\n\\[\\begin{equation}\n\\mathbf{K^e} = \\int_{\\Omega}(\\mathbf{B^e})^T \\mathbf{D} \\hspace{1mm} \\mathbf{B^e} d \\Omega = (\\mathbf{B^e})^T \\mathbf{D} \\hspace{1mm} \\mathbf{B^e}\n\\end{equation}\\]\n\\[\\begin{equation}\n\n\\mathbf{B^e} =  \\frac{1}{2 A^e} \\begin{bmatrix}\n(y_1^e - y_2^e) & 0 & (y_2^e - y_0^e) & 0 & (y_0^e - y_1^e) & 0 & \\\\\n0 & (x_2^e - x_1^e) & 0 & (x_0^e - x_2^e) & 0 & (x_1^e - x_0^e) & \\\\\n(x_2^e - x_1^e) & (y_1^e - y_2^e) & (x_0^e - x_2^e) & (y_2^e - y_0^e) & (x_1^e - x_0^e) & (y_0^e - y_1^e) & \\\\\n\\end{bmatrix}\n\n\n\\end{equation}\\]\n\nclass Element:\n    \n    maxColorVal = -9.9e19\n    minColorVal = 9.9e19\n    colorFunc = lambda x: x\n    \n    def __init__(self, id, nodes):\n        self.id = id\n        self.nodes = self.orderCounterClock(nodes)\n        self.stress = None\n        self.strain = None\n        self.colorVal = 0\n        self.getArea()\n    \n    @property\n    def getmaxColorVal(self):\n        return Element.maxColorVal\n    \n    @property\n    def getminColorVal(self):\n        return Element.minColorVal\n    \n    @property\n    def getcolorFunc(self):\n        return Element.colorFunc\n\n    def getde(self):\n        de_ = []\n        for n in self.nodes:\n            de_.append(n.dx)\n            de_.append(n.dy)\n        self.de = np.array(de_)\n        return self.de\n    \n    def getColor(self):\n        \n        try: x_ = float(self.colorVal - Element.minColorVal)/(Element.maxColorVal - Element.minColorVal)\n        except ZeroDivisionError: x_ = 0.5 # cmax == cmin\n        \n        x = Element.colorFunc(x_)\n        \n        blue  = int(255* min((max((4*(0.75-x), 0.)), 1.)))\n        red   = int(255* min((max((4*(x-0.25), 0.)), 1.)))\n        green = int(255* min((max((4*fabs(x-0.5)-1., 0.)), 1.)))\n        return (red, green, blue)\n    \n    def getArea(self):\n        x1,y1 = self.nodes[0].x, self.nodes[0].y\n        x2,y2 = self.nodes[1].x, self.nodes[1].y\n        x3,y3 = self.nodes[2].x, self.nodes[2].y\n        result = 0.5*((x2*y3 - x3*y2)-(x1*y3- x3*y1)+(x1*y2-x2*y1))\n        if result == 0:\n            result = 1e-20\n        self.area = result\n        return result\n    \n    def getBe(self):\n        x1,y1 = self.nodes[0].x, self.nodes[0].y\n        x2,y2 = self.nodes[1].x, self.nodes[1].y\n        x3,y3 = self.nodes[2].x, self.nodes[2].y\n        B = (0.5/self.area) * np.array([\n            [(y2-y3) ,  0    , (y3-y1),  0   ,   (y1-y2),   0   ],\n            [   0    , (x3-x2),  0    , (x1-x3),     0   ,(x2-x1)],\n            [(x3-x2) , (y2-y3), (x1-x3), (y3-y1), (x2-x1) ,(y1-y2)],\n        ], dtype=np.float64)\n        self.Be = B\n        return B\n        \n    def getKe(self, D):\n        Bie = self.getBe()\n        Ke = self.area* np.matmul(Bie.T, np.matmul(D, Bie))\n        self.Ke = Ke\n        return Ke\n    \n    def orderCounterClock(self, nodes):\n        p1,p2,p3 = nodes[0], nodes[1], nodes[2]\n        val = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y)\n        nodes_ = nodes.copy()\n        if val > 0:\n            nodes[1] = nodes_[0]\n            nodes[0] = nodes_[1]   \n        \n        assembly = []\n        for n in nodes:\n            assembly.append(int(n.id*2))\n            assembly.append(int(n.id*2) +1)\n        self.assembly = assembly\n        \n        return nodes"
  },
  {
    "objectID": "posts/fem/index.html#node",
    "href": "posts/fem/index.html#node",
    "title": "Finite Element Method",
    "section": "Node",
    "text": "Node\nThe following code defines the Node class, which represents a node in a mesh. The class has several attributes and methods that are used to store and manipulate information about the node, such as its coordinates, forces, and displacements.\n\n\n\n\n\nThe init method is used to initialize a new Node object, and accepts the node’s id, x and y coordinates as arguments. The fx and fy attributes are used to store the external forces applied to the node, and the rx and ry attributes are used to store the reaction forces at the node. The dx and dy attributes are used to store the displacements of the node.\nThe dfix property returns a Boolean value indicating whether the node is fixed in both x and y directions. The externalForce property returns a Boolean value indicating whether the node has any external forces applied to it. The eq method is used to compare two Node objects and returns a Boolean value indicating whether they are at the same location. This class can be used to represent nodes in a mesh and perform operations on them.\n\nclass Node:\n    \n    def __init__(self, id, x, y):\n        self.id = id\n        self.x, self.y = x, y\n        self.fx, self.fy = 0.0, 0.0\n        self.rx, self.ry = 0.0 ,0.0\n        self.dx, self.dy = None, None\n        \n    @property\n    def dfix(self):\n        if self.dx == 0.0 and self.dy == 0.0:\n            return True\n        else:\n            return False\n        \n    @property\n    def externalForce(self):\n        if self.fx != 0.0 or self.fy != 0.0:\n            return True\n        else:\n            return False\n        \n    def __eq__(self, obj):\n        if (self.x == obj.x) and (self.y == obj.y):\n            return True\n        else:\n            return False"
  }
]