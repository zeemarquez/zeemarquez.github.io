[
  {
    "objectID": "posts/blockchain_0/index.html",
    "href": "posts/blockchain_0/index.html",
    "title": "Blockchain, ¿qué es eso?",
    "section": "",
    "text": "En este post intento explicar lo que es una blockchain de la forma más simple, visual e interactiva posible. No es necesario tener conocimientos de programación o criptografia para entender como funciona una blockchain. Si quieres entrar más en detalle tengo otro post explicando como programar una blockchain en Python desde cero."
  },
  {
    "objectID": "posts/blockchain_0/index.html#función-hash",
    "href": "posts/blockchain_0/index.html#función-hash",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Función hash",
    "text": "Función hash\nLa función hash es una de las herramientas criptográficas más importantes y es imprescindible para crean una blockchain. Aunque el funcionamiento de una función hash puede ser muy complicado el concepto es bastante simple. Se trata de una función que convierte una entrada (la palabra “hola” por ejemplo) en un a salida que parece aleatoria.\n\n\n\n\n\nLo que hace a la función hash tan útil es que siempre devuelve un resultado del mismo tamaño. Existen muchos tipos de algoritmos hash diferentes, uno de los mas usado es el SHA256, que devuelve 256 bits. Da igual que la entrada de la función sea la letra “a” o el Quijote entero, siempre el resultado son 256 bits. Prueba a experimentar con la función hash:\n#| standalone: true\nimport hashlib as hs\nfrom shiny import *\n\napp_ui = ui.page_fluid(\n  ui.tags.style(\n        \"\"\"\n        .app-col {\n            border: 1px solid white;\n            border-radius: 5px;\n            background-color: #ffffff;\n            padding: 8px;\n            margin-top: 5px;\n            margin-bottom: 2px;\n        }\n        \"\"\"\n    ),\n  \n  ui.row(\n    ui.div(\n                {\"class\": \"app-col\"},\n                ui.p(\n                    ui.input_text(\"x\", \"\", placeholder=\"hola\"), \n                ),\n                ui.p(\n                    ui.output_text(\"txt\"),\n                ),\n            ),\n            align=\"center\",\n)\n)\n\ndef server(input, output, session):\n  @output\n  @render.text\n  def txt():\n    if len(input.x()) == 0:\n      hash = hs.sha256((\"hola\").encode()).hexdigest()\n    else:\n      hash = hs.sha256((input.x()).encode()).hexdigest()\n    return f'{hash}'\n\n\napp = App(app_ui, server, debug=True)\n\nLa función hash es caótica, que quiere decir que un minúsculo cambio a la entrada (por ejemplo, poner la “h” en mayúscula) provoca un resultado completamente diferente. Es importante distinguir caótico de aleatorio, la función hash no es aleatoria, es determinista, siempre devolverá la misma salida a la misma entrada. Se podría comparar la función hash con el doble péndulo, otro ejemplo de sistema caótico. Cambiar un poquito las condiciones iniciales del doble péndulo provoca resultados de movimiento completamente diferentes. En el ejemplo inferior parece que los dos péndulos son iguales al principio, pero en realidad tienen un cambio despreciable en el ángulo inicial, pero este minúsculo cambio es suficiente para alterar por completo el resultado.\n\n\n\n\n\n\n\n\n\n\nOtra característica del sistema de doble péndulo es que pasado un tiempo es prácticamente imposible deducir el estado inicial del péndulo. De la misma forma, es imposible conocer que entrada a la función hash dará un resultado especifico o, en otras palabras, es imposible hacer la función hash al revés. La única forma de saber que resultado dará una entrada es realizando la función hash sobre esa entrada.\nSi recuerdas los problemas mencionados antes, la función hash resuelve uno de los problemas: codificar la información de cada página (o bloque) de una forma única, determinista y con un tamaño fijo. De esta forma los bloques se “encadenan” porque cada bloque contiene el hash del bloque anterior.\n\n\n\n\n\nLa función hash también nos permite implementar la prueba de trabajo. Computar la función hash requiere una cantidad de tiempo. Como podías ver en la función hash interactiva de antes, no se tarda mucho en calcular, pero si se ejecuta varias veces se empieza a notar. Para implementar la prueba de trabajo en una blockchain podemos, por ejemplo, añadir una variable libre (nonce) a la entrada de la función hash y exigir que el hash de cada bloque empiece por \"0000\". Como es imposible saber que entrada resultara en un hash que comience por \"0000\", la única forma es probar y probar hasta acertar. Este proceso de probar miles de entradas posibles para la función hash requiere computación y tiempo. Por ejemplo, usando la palabra \"hola\" como entrada del hash, probamos \"hola_0\", \"hola_1\", \"hola_2\"… Al final después de un tiempo resolvemos la prueba de trabajo, si probamos con \"hola_167537\"obtenemos el hash que comienza con 4 ceros:\n\n0000c24a5157df9c08de36972e30404e463b1e76bbb25007395d455b9494ad77"
  },
  {
    "objectID": "posts/blockchain_0/index.html#firma-digital",
    "href": "posts/blockchain_0/index.html#firma-digital",
    "title": "Blockchain, ¿qué es eso?",
    "section": "Firma digital",
    "text": "Firma digital\nLa firma digital, como una firma real, nos permite firmar información de tal manera que cualquiera pueda comrpobar que efectivamente, esa infromación firmada la hemos creado nosotros. Sin esta herramienta una criptomoneda no podria funcionar ya que culaquier miembro de la blockchain podria hacerse pasar por otra persona. Si nos paramaos a pensar, qué es una firma en realidad, no es más que una modificar un documento con una marca que solo la persona que firma puede hacer. El proceso de firmar un documento es bastante intuitivo, pero ¿cómo puede alguien comprobar que la firma es de verdad?. Aquí es donde entra en juego la encriptación asimetrica. La encriptación no es más que el proceso de bloquear o esconder algo del acceso público. Las puertas normales de nuestras casas son un tipo de “encriptación” simetrica. Tenemos una llave que es la misma que cierra o abre la puerta, el proceso de abrir es simetrico al de cerrar. Lo mismo pasa con los candados de la bici o las taquillas. En cambio, en una encriptación asimetrica hay dos llaves: la que cierra y la que abre. Si nuestras casas tuvieran puertas asimetricas necesitariamos una llave diferente para abrir la puerta que para cerrarla. Parece complicarse para nada, pero esto es extremadamente util para las firmas digitales.\n\n\nEncriptación asimetrica:\n\n\n\nEn una firma digital la llave de cerrar es la llave privada, y la de abrir la pública. La llave pública se genera a partir de la llave privada, pero es imposible conocer la llave privada sabiendo unicamente la pública. Digamos que Alicia tiene un par de llaves publica y privada y quiere firmar una carta. La pública la puede ver cualquiera y privada solo la conoce ella. Alicia encripta una carta usando su llave privada y se la manda a Juan. Recordemos que esa carta ahora unicamente se puede abrir con la llave pública de Alicia. Juan abrr la carta con la llave publica de Alicia y de esta forma Juan sabe que esa carta la ha encriptado Alicia con su llave privada sin tener que conocer cual es la llave privada."
  },
  {
    "objectID": "posts/blockchain_1/index.html",
    "href": "posts/blockchain_1/index.html",
    "title": "Crea tu propia blockchain",
    "section": "",
    "text": "import hashlib as hs\nimport time\n\n\n\n\n\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n\n\n\n\n\n\n\n\n\n\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n\n\n\n\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n        \n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n\n\n\n\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #La direccion desde donde se manda la recompensa de minar\n    \n    def __init__(self):\n        self.difficulty = 2         #El numero de ceros por el que empieza el hash del nuevo bloque\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n        \n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True\n\n\n\n\n\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n\nBlock mined: 00d3103ff5c39cb5a767d1aeb7c7ffc6688d3542c6010931b1a3678394864024\nBlock mined: 00c0aa613e85c91753ada9d17af985dd399f035af6726d41b228c12289867c05\n\nBalance Alice: 75\nBalance Bob: 125\n\n\n\nzcoin.isValid()\n\nTrue"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Blockchain, ¿qué es eso?\n\n\n\n\n\n\n\nbitcoin\n\n\nblockchain\n\n\n\n\n\n\n\n\n\n\n\n28 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\n  \n\n\n\n\nCrea tu propia blockchain\n\n\n\n\n\n\n\npython\n\n\ncode\n\n\nblockchain\n\n\nbitcoin\n\n\n\n\n\n\n\n\n\n\n\n20 nov 2022\n\n\nZee Marquez\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre mi",
    "section": "",
    "text": "¡Hola! Mi nombre es Zee Márquez y soy ingeniero mecánico. Actualmente estoy estudiando un máster de ingeniería aeroespacial especializado en aerodinámica y energía eólica en TU Delft. En este blog voy subiendo curiosidades, artículos y proyectos de temas que me llaman la atención. Entre los temas que abarco en este blog están el blockchain, simulación, optimización y más."
  },
  {
    "objectID": "posts/blockchain_1/index.html#firma-digital",
    "href": "posts/blockchain_1/index.html#firma-digital",
    "title": "Crea tu propia blockchain",
    "section": "Firma digital",
    "text": "Firma digital\npip install eciespy\n\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n\nPrivate:  e4c871e8286b78df6cd630c28e125e02f2a16ff87dcd912e62bb261c563bbb2c\nPublic:  039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64\n\n\n\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\nTrue\n039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64"
  },
  {
    "objectID": "posts/blockchain_1/index.html#transacciones-1",
    "href": "posts/blockchain_1/index.html#transacciones-1",
    "title": "Crea tu propia blockchain",
    "section": "Transacciones",
    "text": "Transacciones\n\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)"
  },
  {
    "objectID": "posts/blockchain_1/index.html#bloque-1",
    "href": "posts/blockchain_1/index.html#bloque-1",
    "title": "Crea tu propia blockchain",
    "section": "Bloque",
    "text": "Bloque\n\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ])"
  },
  {
    "objectID": "posts/blockchain_1/index.html#blockchain-1",
    "href": "posts/blockchain_1/index.html#blockchain-1",
    "title": "Crea tu propia blockchain",
    "section": "Blockchain",
    "text": "Blockchain\n\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True"
  },
  {
    "objectID": "posts/blockchain_1/index.html#prueba-1",
    "href": "posts/blockchain_1/index.html#prueba-1",
    "title": "Crea tu propia blockchain",
    "section": "Prueba",
    "text": "Prueba\n\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n\nMy address: 0215ed3b39244e195468374ab6bb55b50aa8f38276f7d7d7b94c876dd8ea278f68\nAlice address: 02eb29d61de4df9822bfa8acffc3d10640edb49f1cb76147b64fef322580ceb96e\nBob address: 027cfa0eef6c57044baf03b19b6c444b65c40c06f867131c384695281d5464e039\n\n\n\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00eadfbfe69c18d11cc1d261bfe632a5e9ee6f3468811fb30222ae697c6acffa\nMy balance: 100\n\n\n\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n\nBlock mined: 00cf117bec10fc2d03ba9b395d5f24eaacf6f55c75d647d58471805019cb471e\nMy balance: 25"
  }
]