{
  "hash": "16314762f68c137b4ef7c9130078a34c",
  "result": {
    "markdown": "---\ntitle: \"Crea tu propia blockchain\"\nauthor: \"Zee Marquez\"\ndate: \"2022-11-20\"\ncategories: [python, code, blockchain, bitcoin]\nimage: \"block1.jpg\"\npage-layout: full\nlang: es\ntoc: true\nlinestretch: 1.75\nexecute: \n  cache: true\ngfm:\n    mermaid-format: png\ncode-tools: true\n---\n\nEn este post explico como programar una blockchain, especificamente una criptomoneda, desde cero en Python. Te recomiendo que le eches un vistazo a mi otro [post](https://zeemarquez.github.io/posts/blockchain_0/) que explica el funcionamiento de una blockchain.\n\n# Blockchain simple\nNecesitamos istalar la libreria `haslib` para implementar la función hash.\n\n```{.zsh filename=\"Terminal\"}\npip install haslib\n```\nImportamos las librerias `haslib` y `time`:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport hashlib as hs\nimport time\n```\n:::\n\n\n## Transacciones\n\n```{mermaid}\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n```\n\nEmpezaremos creando la clase `Transaction`. Los objetos de este tipo recogen las propiedades de las transacciones, estas son el emisor, receptor y valor de la transacción:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n\n```\n:::\n\n\n## Bloque\n\n```{mermaid}\nclassDiagram\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n```\n\nDefinimos una clase `Block` que representa cada bloque de la blockchain. Los bloques tiene como atributos: el conjunto de transacciones (`transactions`), el sello temporal (`timestamp`) que indica cuando se creo el bloque, el hash del bloque anterior (`prevHash`), el hash del bloque (`hash`) y la variable libre (`nonce`).\nLa función `calculateHash()` calcula el hash del bloque usando el algoritmo SHA256 y tomando como entrada los atributos del bloque.\nLa función `mineBlock(difficulty)` ejecuta la prueba de trabajo en un bucle que incrementa la variable `nonce` hasta que encuentra el hash correspondiente que comienza con el numero de ceros especificado por la dificultad de minado.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n```\n:::\n\n\n## Blockchain\n\n```{mermaid}\nclassDiagram\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n```\n\nLa clase `Blockchain` tiene como atributos la difficultad de mindao, la recompensa de minado, la lista chain que contiene los bloques y la lista de transacciones pendientes para añadir al siguiente bloque. Al inicializar un objeto `Blockchain` se crea el bloque genesis (`createGenBlock()`). La función `addBlock(newBlock)` añade un nuevo bloque a la cadena obteniendo el hash del ultimo bloque y minando el nuevo bloque. La función `minePending(minnerAddress)` coge las transacciones pendientes y añade la transacción de recompensa de minado. Posteriormente crea un nuevo bloque, ejecuta la función `addBlock(newBlock)` con el nuevo bloque creado y vacia la lista de transacciones pendientes.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #La direccion desde donde se manda la recompensa de minar\n    \n    def __init__(self):\n        self.difficulty = 2         #El numero de ceros por el que empieza el hash del nuevo bloque\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True\n\n```\n:::\n\n\n## Prueba\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 007277ad9cf1a1dca10f0201c4b32bb2bb2cd198f9ef024b2bc39a80360716b5\nBlock mined: 00e2158cfb1f6986161857e7ad8bea85cd300d0f6fd4fa2b3382a0eed6fa78ea\n\nBalance Alice: 75\nBalance Bob: 125\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nzcoin.isValid()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nTrue\n```\n:::\n:::\n\n\n# Blockchain segura\n\n## Firma digital\n\n```zsh\npip install eciespy\n```\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrivate:  bea7d97393649bde46ba480f3525bd20e80cb4c03ddc5fc3c032f60e1a1f16ae\nPublic:  0210730f68e5ee879de88c5dffc59fe2f6f5fb6224d777df3936e4a28be507420f\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n0210730f68e5ee879de88c5dffc59fe2f6f5fb6224d777df3936e4a28be507420f\n```\n:::\n:::\n\n\n## Transacciones\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)\n\n```\n:::\n\n\n## Bloque\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ]) \n```\n:::\n\n\n## Blockchain\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True\n\n```\n:::\n\n\n## Prueba\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy address: 03c96502f32ef144d419cc758a0da0de465eebb592b3589bcebb013794d0a300d8\nAlice address: 0349de61e8f48c03d30fbfd21b5f4ac1ccbd5efe0f402014afdef407c96d633659\nBob address: 0210834527148b0a921a699d0571e95b16dfef757cdf1c0d8acf6e633956935a75\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 00b855101a5d9524f68bef1f7f3f7c41bbe3887a34937f514eb7d13302cea389\nMy balance: 100\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 0054871538a7792aa2674186fdad43e2e69393bfd2b4fa1dc708f44b98424f8c\nMy balance: 25\n```\n:::\n:::\n\n\n# Referencias\n\n<div style=\"text-align: left\"> \n\n* Savjee, *SavjeeCoin* <https://github.com/Savjee/SavjeeCoin>\n\n</div>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}