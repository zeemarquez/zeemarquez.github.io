{
  "hash": "71f01b5e7fc2defd1783a8e3426af7e9",
  "result": {
    "markdown": "---\ntitle: \"Crea tu propia blockchain\"\nauthor: \"Zee Marquez\"\ndate: \"2022-11-18\"\ncategories: [news, code, analysis]\nimage: \"block1.jpg\"\npage-layout: full\nlang: es\nexecute: \n  cache: true\ngfm:\n    mermaid-format: png\n---\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport hashlib as hs\nimport time\n```\n:::\n\n\nFirst we will create a \n\n\n```{mermaid}\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n```\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n        \n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #La direccion desde donde se manda la recompensa de minar\n    \n    def __init__(self):\n        self.difficulty = 2         #El numero de ceros por el que empieza el hash del nuevo bloque\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n        \n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True\n\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 00d3103ff5c39cb5a767d1aeb7c7ffc6688d3542c6010931b1a3678394864024\nBlock mined: 00c0aa613e85c91753ada9d17af985dd399f035af6726d41b228c12289867c05\n\nBalance Alice: 75\nBalance Bob: 125\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nzcoin.isValid()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nTrue\n```\n:::\n:::\n\n\n```zsh\npip install eciespy\n```\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrivate:  e4c871e8286b78df6cd630c28e125e02f2a16ff87dcd912e62bb261c563bbb2c\nPublic:  039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n039dd7b4c6ae39fded9abf5be889843b8bb9918a94e22a69e8d5d3e1c5d1e1ab64\n```\n:::\n:::\n\n\n# Secure Blockchain\n\nNow we will implement the secure blockchain\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)\n\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ]) \n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True\n\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy address: 0215ed3b39244e195468374ab6bb55b50aa8f38276f7d7d7b94c876dd8ea278f68\nAlice address: 02eb29d61de4df9822bfa8acffc3d10640edb49f1cb76147b64fef322580ceb96e\nBob address: 027cfa0eef6c57044baf03b19b6c444b65c40c06f867131c384695281d5464e039\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 00eadfbfe69c18d11cc1d261bfe632a5e9ee6f3468811fb30222ae697c6acffa\nMy balance: 100\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 00cf117bec10fc2d03ba9b395d5f24eaacf6f55c75d647d58471805019cb471e\nMy balance: 25\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}