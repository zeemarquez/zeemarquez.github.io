{
  "hash": "553741ec2c943291a8b2f8d5a1bfaed3",
  "result": {
    "markdown": "---\ntitle: \"Make your own blockchain\"\nauthor: \"Zee Marquez\"\ndate: \"2022-11-20\"\ncategories: [python, code, blockchain, bitcoin]\nimage: \"block1.jpg\"\npage-layout: full\nlang: en\ntoc: true\nlinestretch: 1.75\nexecute: \n  cache: true\ngfm:\n    mermaid-format: png\ncode-tools: true\n---\n\nIn this post I explain how to program a blockchain, specifically a cryptocurrency, from scratch in Python. I recommend that you take a look at my other [post](https://zeemarquez.github.io/posts/blockchain_0/) that explains how a blockchain works.\n\n# simple blockchain\nWe need to install the `haslib` library to implement the hash function.\n\n```{.zsh filename=\"Terminal\"}\npip install haslib\n```\nWe import the `haslib` and `time` libraries:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport hashlib as hs\nimport time\n```\n:::\n\n\n## Transactions\n\n```{mermaid}\nclassDiagram\n    class Transaction\n    Transaction : +sender\n    Transaction : +receiver\n    Transaction : +value\n\n```\n\nWe'll start by creating the `Transaction` class. Objects of this type collect the properties of the transactions, these are the sender, receiver and value of the transaction:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n\n```\n:::\n\n\n## Block\n\n```{mermaid}\nclassDiagram\n    class Block\n    Block : +timestamp\n    Block : +List~Transaction~ transactions\n    Block : +prevHash\n    Block : +hash\n    Block : +nonce\n    Block : +calculateHash()\n    Block : +mineBlock(difficulty)\n```\n\nWe define a `Block` class that represents each block on the blockchain. The blocks have as attributes: the set of transactions (`transactions`), the time stamp (`timestamp`) that indicates when the block was created, the hash of the previous block (`prevHash`), the hash of the block (`hash `) and the free variable (`nonce`).\nThe `calculateHash()` function calculates the hash of the block using the SHA256 algorithm and taking the block's attributes as input.\nThe `mineBlock(difficulty)` function executes the proof of work in a loop that increments the `nonce` variable until it finds the corresponding hash that starts with the number of zeroes specified by the mining difficulty.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, ''.join(str(x) for x in self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n```\n:::\n\n\n## Blockchain\n\n```{mermaid}\nclassDiagram\n    class Blockchain\n    Blockchain : +difficulty\n    Blockchain : +miningReward\n    Blockchain : +List~Block~ chain\n    Blockchain : +pendingTransactions\n    Blockchain : +createGenBlock()\n    Blockchain : +getLastBlock()\n    Blockchain : +addBlock(newBlock)\n    Blockchain : +minePending(minerAddress)\n    Blockchain : +stageTransaction(transaction)\n    Blockchain : +isValid()\n    Blockchain : +checkBalance(address)\n    Blockchain : +isTransactionValid(transaction)\n\n```\n\n\nThe `Blockchain` class has as attributes the difficulty of mining, the mining reward, the chain list that contains the blocks and the list of pending transactions to add to the next block. Initializing a `Blockchain` object creates the genesis block (`createGenBlock()`). The `addBlock(newBlock)` function adds a new block to the chain by getting the hash of the last block and mining the new block. The `minePending(minnerAddress)` function takes the pending transactions and adds the mining reward transaction. It then creates a new block, executes the `addBlock(newBlock)` function with the newly created block, and clears the list of pending transactions.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nclass Blockchain:\n    \n    sysAddress = \"0000\"     #The address from which the mining reward is sent\n    \n    def __init__(self):\n        self.difficulty = 2         #The number of zeros with which the hash of the new block begins\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            print(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            \n            return False\n        else:\n            return True\n\n```\n:::\n\n\n## Test\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nzcoin = Blockchain()\n\nzcoin.minePending('alice')\n\nzcoin.stageTransaction(Transaction('alice', 'bob', 25))\n\nzcoin.minePending('bob')\n\nprint('\\nBalance Alice:', zcoin.checkBalance('alice'))\nprint('Balance Bob:', zcoin.checkBalance('bob'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 0042e2568d4893d988de77aec36f435e9724f4b68d8fc2c8097b61c96ebe5afe\nBlock mined: 00c8327f367e43fcf9d129a5f6282c2458a8baa765a92afbff3847724f6287ac\n\nBalance Alice: 75\nBalance Bob: 125\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nzcoin.isValid()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nTrue\n```\n:::\n:::\n\n\n# Safe Blockchain \n\n## Digital signature\n\n```zsh\npip install eciespy\n```\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfrom ecies import utils\nfrom ecies import encrypt, decrypt\nimport ecies \n\ndef genKeyPair():\n    private_key = utils.generate_key()\n    public_key = private_key.public_key\n    return (private_key.to_hex(),public_key.format().hex())\n\ndef sign(data, signingKey):\n    k = utils.generate_key().from_hex(signingKey)\n    return k.sign(data.encode())\n    \ndef verify(data, signature, publicKey):\n    try:\n        kpub = ecies.hex2pub(publicKey)\n    except:\n        return False\n    return kpub.verify(signature, data.encode())\n    \n    \ndef getPublicKey(private_key):\n    k = utils.generate_key().from_hex(private_key)\n    return k.public_key.format().hex()\n\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprivate_key, public_key = genKeyPair()\n\nprint('Private: ', private_key)\nprint('Public: ', public_key)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrivate:  87d8dee553a45e174be1f39d05b5a40e4f24d8aa6dfc8f8ceaa2753751bd0123\nPublic:  0272ec1b8fe16cec26ae254009ef1cd9cf5b3f9fdc969b419004e5aedacd511210\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nsig = sign('message', private_key)\n\nprint(verify('message', sig, public_key))\n\nprint(getPublicKey(private_key))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n0272ec1b8fe16cec26ae254009ef1cd9cf5b3f9fdc969b419004e5aedacd511210\n```\n:::\n:::\n\n\n## Transactions\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nclass Transaction:\n    def __init__(self, sender, receiver, value):\n        self.sender = sender\n        self.receiver = receiver\n        self.value = value\n        self.signature = None\n        \n    def calculateHash(self):\n        \n        return hs.sha256((''.join([self.sender, self.receiver, str(self.value)])).encode()).hexdigest()\n    \n    def signTransaction(self, signKey):\n        \n        if getPublicKey(signKey) != self.sender:\n            print(\"You cannot sign transactions for other wallets!\")\n            \n        hashTx = self.calculateHash()\n        self.signature =  sign(hashTx, signKey)\n        \n    def isValid(self):\n        \n        if self.sender == Blockchain.sysAddress:\n            return True\n        \n        if self.signature == None:\n            return False\n        \n        public_key = getPublicKey(self.sender)\n        \n        return verify(self.calculateHash(), self.signature, public_key)\n\n```\n:::\n\n\n## Block\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nclass Block:\n    def __init__(self, timestamp, transactions):\n        self.timestamp = timestamp\n        self.transactions = transactions\n        self.prevHash = None\n        self.hash = None\n        self.nonce = 0\n\n    def calculateHash(self):\n        return hs.sha256((''.join([self.timestamp, str(self.transactions), self.prevHash, str(self.nonce)])).encode()).hexdigest()\n    \n    def mineBlock(self, difficulty):\n        while True:\n            self.hash = self.calculateHash()\n            if self.hash[0:difficulty] == \"\".join([\"0\" for x in range(difficulty)]):\n                break\n            self.nonce += 1\n            \n        print(\"Block mined:\",self.hash)\n        \n    def checkValidTransactions(self):\n        for tx in self.transactions:\n            if not tx.isValid():\n                return False\n        return True\n    \n    def __str__(self):\n        return '\\n'.join([ '|' + key + '|\\t' + self.__dict__[key].__str__() +'|' for key in self.__dict__ ]) \n```\n:::\n\n\n## Blockchain\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nclass Blockchain:\n    \n    sysAddress = \"0000\"\n    \n    def __init__(self):\n        self.difficulty = 2\n        self.miningReward = 100\n        self.chain = [self.createGenBlock()]\n        self.pendingTransactions = []\n        \n    def createGenBlock(self):\n        genBlock = Block(str(time.time()),[Transaction(Blockchain.sysAddress,'satoshi',100)])\n        genBlock.prevHash = '0'\n        genBlock.hash = genBlock.calculateHash()\n        return genBlock\n    \n    def getLastBlock(self):\n        return self.chain[-1]\n    \n    def addBlock(self, newBlock):\n        newBlock.prevHash = self.getLastBlock().hash\n        newBlock.mineBlock(self.difficulty)\n        self.chain.append(newBlock)\n    \n    def minePending(self, minerAddress):\n        self.pendingTransactions.append(Transaction(Blockchain.sysAddress, minerAddress, self.miningReward))\n        block = Block(str(time.time()), self.pendingTransactions)\n        self.addBlock(block)\n        self.pendingTransactions = []\n        \n    def stageTransaction(self, transaction):\n        if self.isTransactionValid(transaction):\n            self.pendingTransactions.append(transaction)\n        else:\n            raise Exception(\"Transaction invalid\")\n        \n    def isValid(self):\n        for i in range(1,len(self.chain)):\n            \n            if self.chain[i-1].hash != self.chain[i].prevHash:\n                return False\n            \n            if self.chain[i].hash != self.chain[i].calculateHash():\n                return False\n            \n            #Added check of valid transactions\n            if not self.chain[i].checkValidTransactions():\n                return False\n            \n        return True\n    \n    def checkBalance(self, address):\n        balance = 0\n        for block in self.chain:\n            for trans in block.transactions:\n                if trans.sender == address:\n                    balance -= trans.value\n                if trans.receiver == address:\n                    balance += trans.value\n        return balance\n    \n    def isTransactionValid(self, transaction):\n        if self.checkBalance(transaction.sender) < transaction.value:\n            return False\n        else:\n            return True\n\n```\n:::\n\n\n## Test\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nmyKey, myWalletAddress = genKeyPair()\n\nAliceKey, AliceWalletAddress = genKeyPair()\nBobKey, BobWalletAddress = genKeyPair()\n\ndel AliceKey, BobKey\n\nprint('My address:', myWalletAddress)\nprint('Alice address:', AliceWalletAddress)\nprint('Bob address:', BobWalletAddress)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy address: 032fdc54ce91b789d9525cbfc9c8661e9f00b6cef2eb37e52a22f4687f3bedb822\nAlice address: 02f6dbaf69c7a9cc53ca3a71c1936715a24cf7c7b759b01ee6be374d9935551ded\nBob address: 02f1d44e43da4034ee0dc51e9712155a11eb14081dcc0ba0bf3b5c1aed6ed90c33\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nzcoin = Blockchain()\n\nzcoin.minePending(myWalletAddress)\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 00ff4f95dcf593f48cbe416e77bb3f78fe7f44438c79163ee1d5c8ab844285c1\nMy balance: 100\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ntx1 = Transaction(myWalletAddress, AliceWalletAddress, 50)\ntx2 = Transaction(myWalletAddress, BobWalletAddress, 25)\n\ntx1.signTransaction(myKey)\ntx2.signTransaction(myKey)\n\nzcoin.stageTransaction(tx1)\nzcoin.stageTransaction(tx2)\n\nzcoin.minePending(AliceWalletAddress)\n\nprint('My balance:',zcoin.checkBalance(myWalletAddress))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlock mined: 00103396896dcc7494efa26116ca9852af780ed22987bcdea49aaf2cfed6ca3c\nMy balance: 25\n```\n:::\n:::\n\n\n# References\n\n<div style=\"text-align: left\"> \n\n* Savjee, *SavjeeCoin* <https://github.com/Savjee/SavjeeCoin>\n\n</div>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}